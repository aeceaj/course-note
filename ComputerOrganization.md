# COMPUTER ORGANIZATION

[toc]

## 计算机系统概述

### 计算机硬件

#### 冯·诺伊曼机

1. 采用“存储程序”的工作方式
2. 由运算器、存储器、控制器、输入设备、输出设备 5 个部件组成
3. 指令和数据以同等地位存储在存储器中，形式上没有区别
4. 指令和数据以二进制表示。指令由操作码和地址码组成

#### 计算机功能部件

1. 输入设备：键盘（基本输入设备）、鼠标、扫描仪
2. 输出设备：显示器（基本输入设备）、打印机
3. 存储器：主存（内存）、辅存（外存）

   - CPU 可直接访问主存
   - 主存按地址存取
   - 地址寄存器（MAR）$\longrightarrow$ 存储体 $\longleftrightarrow$ 数据寄存器（MDR）
   - 存储元件存储一位二进制，存储单元存储一串二进制，称为**存储字**，位数为**存储字长**，为 1B 或偶数字节
   - MAR 用于寻址，位数对应存储单元的个数，与 PC 位数相等
   - MDR 位数与存储字长相等
   - 现代计算机中 MAR 和 MDR 位于 CPU 内

4. [运算器](#运算器)

   - 核心为算术逻辑单元（ALU），包含若干通用寄存器。累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）
   - 包含程序状态寄存器（PSW），也称标志寄存器，存放 ALU 运算得到的标志信息或处理机状态信息

5. [控制器](#控制器)

   - 程序计数器（PC）存放当前欲执行指令的地址，可自动加 1 形成下一条指令的地址，与 MAR 之间有直接通路
   - 指令寄存器（IR）存放当前指令，内容来自 MDR。操作码 OP(IR) 送至 CU，地址码 Ad(IR) 送至 MAR
   - 控制单元（CU）分析指令并发出各种微操作命令序列

运算器和控制器一般集成在一个芯片上，称为中央处理器（CPU）。CPU 和主存构成**主机**，其他硬件装置统称为**外设**  
CPU 和主存之间通过一组总线相连，包含地址、控制、数据 3 组信号线

### 计算机软件

1. 系统软件：操作系统（OS）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务型程序
2. 应用软件

### 计算机语言

1. 机器语言
   : 二进制代码语言。计算机唯一可以直接识别和执行的语言
2. 汇编语言
   : 用英文单词或缩写代替二进制指令代码。通过汇编程序转换为机器语言
3. 高级语言
   : 通过编译程序转换为汇编语言，或直接翻译为机器语言

#### 翻译程序

1. 汇编程序
   : 将汇编语言翻译成机器语言
2. 解释程序
   : 将源程序中的语句逐条翻译成机器指令并立即执行
3. 编译程序
   : 将高级语言翻译成汇编语言或机器语言

### 工作原理

#### 存储程序工作方式

1. 从主存取指令：根据 PC 中的地址访问主存。程序执行前将第一条指令的地址放入 PC
2. 对指令进行译码
3. 计算下条指令地址：若当前为顺序型指令，PC 加上当前指令长度；若当前为跳转型指令，PC 存入指定的目标地址
4. 取操作数并执行
5. 将结果送回存储器

#### 源程序到可执行文件

1. 预处理
   : 源程序 $\longrightarrow$ 修改后的源程序
2. 编译
   : 预处理后的源程序 $\longrightarrow$ 汇编程序
3. 汇编
   : 汇编程序 $\longrightarrow$ 可重定位目标文件
4. 链接
   : 可重定位目标文件 $\longrightarrow$ 可执行文件

### 计算机性能指标

#### 字长

- 计算机进行一次整数运算能处理的二进制位数
- 与 CPU 寄存器位数、加法器有关。一般等于内部寄存器的大小
- 字长越长，数据表示范围越大，计算精度越高
- 通常为 Byte 的整数倍

#### 数据通路带宽

- 数据总线一次能并行传送信息的位数
- 外部数据总线的宽度，与 CPU 内部数据总线的宽度可能不同
- 各个子系统通过数据总线连接形成的数据传送路径称为**数据通路**

#### 主存容量

- MAR 的位数反映存储单元的个数，表示可寻址的最大范围

#### 运算速度

- 吞吐量
  : 系统在单位时间内处理请求的数量。主要取决于主存的存取周期
- 响应时间
  : 从发送请求到响应得到结果的等待时间。包括 CPU 时间和等待时间
- CPU 时钟周期
  : 主频的倒数，CPU 中最小的时间单位。执行指令的每个动作至少需要 1 个时钟周期
- 主频
  : 主时钟的频率
- CPI
  : 执行一条指令所需的时钟周期数。为程序或指令集中所有指令的平均值
- CPU 执行时间
  : 运行一个程序花费的时间

  $$ 执行时间=\frac{总时钟周期数}{主频}=\frac{指令条数\times\text{CPI}}{主频} $$

- MIPS
  : 每秒执行多少百万条指令。不同指令集下，实现相同功能需要的指令数量不同
- FLOPS
  : 每秒执行多少次浮点运算

## 数据的表示和运算

### 进位计数法

一个 $r$ 进制数可表示为

$$ K_nr^n+K_{n-1}r^{n-1}+\cdots+K_0r^0+K_{-1}r^{-1}+\cdots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_ir^i $$

$n$ ~ $0$ 为整数位，$-1$ ~ $-m$ 为小数位。$r^i$ 为第 $i$ 位的位权，$K_i$ 的取值为 $0,1,\cdots,r-1$

- 二进制
- 八进制：二进制的一种书写形式，1 位八进制对应 3 位二进制
- 十六进制：二进制的一种书写形式，1 位十六进制对应 4 位二进制

### 进制转换

#### 二进制 $\leftrightarrows$ 八进制/十六进制

- 二进制 $\to$ 八进制/十六进制：整数部分高位补 0，3/4 位一组；小数部分低位补 0，3/4 位一组。每组转换为对应八进制数/十六进制数
- 八进制/十六进制 $\to$ 二进制：每位转换为 3/4 位二进制数，去掉整数部分高位 0 和小数部分低位 0

#### 八进制 $\leftrightarrows$ 十六进制

八进制 $\leftrightarrows$ 二进制 $\leftrightarrows$ 十六进制

#### $r$ 进制 $\to$ 十进制

按权展开相加法

$$ K_nr^n+K_{n-1}r^{n-1}+\cdots+K_0r^0+K_{-1}r^{-1}+\cdots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_ir^i $$

#### 十进制 $\to$ $r$ 进制

基数乘除法

- 整数部分除基取余：先余为低，后余为高，商为 0 时结束
- 小数部分乘基取整：先整为高，后整为低，积为 1（或满足精度要求）时结束

:memo: 并不是每个十进制小数都可以用二进制准确表示

### 二进制编码的十进制数（Binary-Coded Decimal, BCD）

采用 4 位二进制数表示 0-9  
包含 6 种冗余状态

- 8421 码
  : 各位权值从高到低为 8 4 2 1，两数相加大于 9 需要再加 6 修正
- 余 3 码
  : 在 8421 码的基础上加 3
- 2421 码
  : 各位权值从高到低为 2 4 2 1，其中大于等于 5 时最高位为 1，小于 5 时最高位为 0

### 定点数

- 定点小数：纯小数，小数点在符号位之后 $x_0.x_1x_2\cdots x_n$
- 定点整数：纯整数，小数点在最低位之后 $x_0x_1x_2\cdots x_n.$

#### 原码

最高位符号位，其余表示数的绝对值

1. 纯小数

   字长为 $n+1$，表示范围为 $2^{-n}-1\leq x\leq1-2^{-n}$

2. 纯整数

   字长为 $n+1$，表示范围为 $1-2^n\leq x\leq2^n-1$

- 原码的表示范围关于原点对称
- 0 的表示不唯一，有正零和负零两种形式

#### 补码

正数同原码，负数数值位为原码**取反加一**

1. 纯小数

   字长为 $n+1$，表示范围为 $-1\leq x\leq1-2^{-n}$
   比原码多表示 $-1$，表示为 10000000

2. 纯整数

   字长为 $n+1$，表示范围为 $-2^n\leq x\leq2^n-1$
   比原码多表示 $-2^n$，表示为 10000000

3. 变形补码（小数）

   又称模 4 补码。双符号位，00 为正，11 为负

- 0 的补码表示唯一
- 适合加减运算
- 符号位和数值位一起右移并保持原符号位不变，实现除法功能

#### 反码

正数同原码，负数数值位为原码取反

- 0 的表示不唯一
- 负数补码末位减 1 可得到反码

#### 移码

在真值上加上一个偏置值，字长为 $n+1$ 时，偏置值通常取 $2^n$。只能表示整数

- 0 的表示唯一，表示为 10000000
- 移码和补码仅差一个符号位，移码中 1 为正，0 为负
- 保持了数据原有的大小顺序

### 整数表示

#### 无符号整数

字长为 $n$，表示范围为 $0\leq x\leq2^n-1$

#### 有符号整数

计算机中的有符号整数都用 **[补码](#补码)** 表示

### 运算方法和运算电路

#### 一位全加器（FA）

输入：加数 $A_i$，加数 $B_i$，低位传来的进位 $C_{i-1}$  
输出：本位和 $S_i$，向高位的进位 $C_i$

$$
S_i=A_i\oplus B_i\oplus C_{i-1}\\
C_i=A_iB_i+(A_i\oplus B_i)C_{i-1}
$$

#### 串行进位加法器

$n$ 个全加器相连得到 $n$ 位加法器。串行进位（行波进位）中每一级进位依赖于前一级，进位信号逐级形成

- $C_n=1$ 时高位丢失
- 最长运算时间主要由进位信号的传递时间决定

#### 并行进位加法器

进位产生函数：$G_i=A_iB_i$  
进位传递函数：$P_i=A_i\oplus B_i$  
进位表达式：$C_i=G_i+P_iC_{i-1}$

$$
\begin{aligned}
    C_1&=G_1+P_1C_0\\
    C_2&=G_2+P_2C_1=G_2+P_2G_1+P_2P_1C_0\\
    C_3&=G_3+P_3C_2=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0\\
    C_4&=G_4+P_4C_3=G_4+P_4G_3+P_4P_3G_2+P_4P_3P_2G_1+P_4P_3P_2P_1C_0
\end{aligned}
$$

$C_i$ 仅依赖于 $A_i$，$B_i$，$C_0$，可几乎同时计算各位和

- 电路称为先行进位部件（CLA）
- 位数增加使得逻辑表达式与电路结构更加复杂
- 可分组串接，组内使用 CLA 先行进位，组间串行进位
- 采用组内和组间都并行，得到两级或多级先行进位加法器

#### 带标志加法器

溢出标志 $\text{OF}=C_n\oplus C_{n-1}$  
符号标志 $\text{SF}=F_{n-1}$，即和的最高位  
零标志 $\text{ZF}=1\iff F=0$  
进位/借位标志 $\text{CF}=C_\text{out}\oplus C_\text{in}$

- 实际电路使用多级先行进位方式

#### 算术逻辑单元（ALU）

ALU 的核心是带标志加法器

输入 $n$ 位操作数 $A,B$，进位输入 $C_\text{in}$，操作控制端 ALUop 决定执行的功能

- 使用多路选择器（MUX）选择输出结果
- ALU 可以实现左移和右移的移位操作

### 定点数的移位

#### 算术移位

对象为有符号数，符号位保持不变

<table>
<thead>
  <tr>
    <th></th>
    <th>码制</th>
    <th>添补</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>正数</td>
    <td></td>
    <td>0</td>
  </tr>
  <tr>
    <td rowspan="4">负数</td>
    <td>原码</td>
    <td>0</td>
  </tr>
  <tr>
    <td rowspan="2">补码</td>
    <td>左移 0</td>
  </tr>
  <tr>
    <td>右移 1</td>
  </tr>
  <tr>
    <td>反码</td>
    <td>1</td>
  </tr>
</tbody>
</table>

- 补码低位起第一个 1，其左侧与反码相同，右侧与原码相同，因此补码左移同原码，右移同反码
- 左移不溢出相当于乘 2，右移忽略低位舍弃相当于除以 2

:memo: 实际移位时，符号位和数值位一同移位。故补码左移时，要求**符号位和最高有效位相同**，此时左移有效（无溢出）

#### 逻辑移位

操作数视为无符号数。左移高位舍弃，低位补 0；右移低位舍弃，高位补 0

#### 循环移位

1. 大循环：带进位标志位 CF
2. 小循环：不带进位标志位。移出的位同时进入标志位 CF

### 定点数的加减

#### 补码加减

$$
\begin{aligned}
    [A+B]_{2s}&=[A]_{2s}+[B]_{2s}\\
    [A-B]_{2s}&=[A]_{2s}+[-B]_{2s}
\end{aligned}
$$

- 符号位与数值位同时参与运算，符号由运算直接得出
- 高位丢弃

#### 补码加减运算电路

一个数的补码为 $Y$，其相反数的补码为 $\overline{Y}+1$  
加法器的一端添加 $n$ 位反向器实现取反功能  
控制端 $\text{Sub}=0$ 表示加法，$\text{Sub}=1$ 表示减法  
$C_\text{in}=\text{Sub}$

- $\text{ZF}=1$ 表示结果 $F=0$
- $\text{OF}=1$ 表示发生溢出。仅用于有符号运算
- $\text{SF}=F_{n-1}$ 表示结果的符号。仅用于有符号运算
- $\text{CF}=C_\text{out}\oplus C_\text{in}=C_\text{out}\oplus\text{Sub}$ 表示是否发生溢出。仅用于无符号运算

#### 溢出判别

**同号数相加**或**异号数相减**才可能溢出

1. 一位符号位

   机器中实现的均为加法操作，因此只要操作数同号且结果异号即表示溢出

   $$ V=A_sB_s\overline{S_s}+\overline{A_sB_s}S_s $$

2. 双符号位

   $S_{s1}S_{s2}=00$ 表示正数，无溢出  
   $S_{s1}S_{s2}=01$ 表示正溢出  
   $S_{s1}S_{s2}=10$ 表示负溢出  
   $S_{s1}S_{s2}=11$ 表示负数，无溢出

   $$ V=S_{s1}\oplus S_{s2} $$

3. 一位符号位 + 进位情况

   符号位进位 $C_s$ 与最高位进位 $C_1$ 相同说明无溢出，否则有溢出

   $$ V=C_s\oplus C_1 $$

#### 原码加减

符号位相同绝对值相加  
符号位不同绝对值相减，结果符号与绝对值大者相同

### 定点数的乘除

$X=x_sx_1x_2\cdots x_n$  
$Y=y_sy_1y_2\cdots y_n$

#### 原码一位乘法

1. $P_s=x_s\oplus y_s$，$|P|=|X|\times|Y|$
2. 部分积初值为 0
3. $i=n\to1$：若 $y_i=1$，部分积加上 $|X|$，右移一位；若 $y_i=0$，右移一位

- 右移操作为逻辑右移
- 做加法时可能产生进位，因此取双符号位

#### 补码一位乘法（Booth 算法）

1. 符号位参与运算，部分积/$X$ 双符号位，乘数 $Y$ 单符号位
2. 乘数末位增设 $y_{n+1}$，初值为 0
3. 根据 $y_ny_{n+1}$ 的值决定操作

   | $y_n$ | $y_{n+1}$ |          操作           |
   | :---: | :-------: | :---------------------: |
   |   0   |     0     |        右移一位         |
   |   0   |     1     | 部分积加 $X$，右移一位  |
   |   1   |     0     | 部分积加 $-X$，右移一位 |
   |   1   |     1     |        右移一位         |

4. 右移操作为补码算术右移，部分积和乘数同时右移
5. 进行 $n+1$ 次操作，但最后一次不右移

#### 原码除法（不恢复余数法）

1. $Q_s=x_s\oplus y_s$，$|Q|=|X|/|Y|$
2. 第一步，被除数减去除数（$|X|-|Y|=|X|+[-|Y|]_{2s}$）
3. 余数为正，商上 1，余数和商左移一位，减去除数；余数为负，商上 0，余数和商左移一位，加上除数
4. 保证余数与被除数同号，若 $n+1$ 步余数为负，需要加上 $|Y|$ 得到正确的余数

#### 补码除法（加减交替法）

1. 符号位参与运算，采用双符号位
2. 第一步，被除数和除数同号相减，异号相加
3. 余数和除数同号，商上 1，余数和商左移一位，减去除数；余数和除数异号，商上 0，余数和商左移一位，加上除数
4. 商末位恒置 1

### 整数类型转换

#### 有符号和无符号整数

有符号整数使用补码表示，无符号整数为二进制真值  
强制类型转换时二进制位值不变

#### 不同字长整数

1. 大字长 $\to$ 小字长：高位直接截断
2. 小字长 $\to$ 大字长：对高位进行填充。无符号用 0 填充，有符号用符号位填充

### 数据的存储和排列

#### 大端方式和小端方式存储

使用最低有效字节（LSB）和最高有效字节（MSB）表示数的低位和高位

1. 大端：MSB 在前
2. 小端：LSB 在前

#### 边界对齐方式存储

1. 边界对齐：所有数据一次访存即可取出，填充空白字节。**空间换时间**
2. 边界不对齐：充分利用存储空间，数据可能需要多次访存取出，并且需要调整连接

- RISC 通常采用边界对齐方式

### 浮点数

$$ N=(-1)^S\times M\times R^E $$

- 符号位 $S$
- 尾数 $M$：二进制定点小数，原码表示。反映浮点数的精度
- 阶码 $E$：二进制定点整数，移码表示。反映小数点的实际位置和浮点数的表示范围
- 基数 $R$：隐含，约定为 2、4、16 等

#### 浮点数的表示范围

浮点数的表示范围关于原点对称

1. 上溢：正上溢（$x>+\max$），负上溢（$x<-\min$）。进行溢出处理
2. 下溢：正下溢（$0<x<+\min$），负下溢（$-\min<x<0$）。视作 0 处理

#### 浮点数规格化

调整尾数和阶码的大小，使尾数最高位为有效值

- 左规：尾数最高位不是有效位。尾数左移，阶码 $-1$（基数为 2）。可能要进行多次
- 右规：尾数有效位到小数点前。尾数右移，阶码 $+1$（基数为 2），最后一位移出时考虑舍入。只需进行一次

规格化尾数 $M$ 满足 $\frac{1}{R}\leq|M|<1$

#### IEEE 754

浮点数格式：{ 符号位 $S$ | 阶码 $E$ | 尾数 $M$ }

|    类型    | 数符  | 阶码  | 尾数（数值） | 总位数 |    偏置值    |
| :--------: | :---: | :---: | :----------: | :----: | :----------: |
|  短浮点数  |   1   |   8   |      23      |   32   |   7F (127)   |
|  长浮点数  |   1   |  11   |      52      |   64   |  3FF (1023)  |
| 临时浮点数 |   1   |  15   |      64      |   80   | 3FFF (16383) |

短浮点数和长浮点数采取**隐藏位策略**，尾数实际上隐藏了最高位的 1（**整数部分**）

$$
\begin{aligned}
    N_\text{float}&=(-1)^S\times1.M\times2^{E-127}\\
    N_\text{double}&=(-1)^S\times1.M\times2^{E-1023}
\end{aligned}
$$

|            | 阶码  |    尾数     |            数值             |
| :--------: | :---: | :---------: | :-------------------------: |
| Float min  |   1   |      0      |     $1.0\times2^{-126}$     |
| Float max  |  254  | 11$\cdots$1 | $1.11\cdots1\times2^{127}$  |
| Double min |   1   |      0      |    $1.0\times2^{-1022}$     |
| Double max | 2046  | 11$\cdots$1 | $1.11\cdots1\times2^{1023}$ |

阶码全为 0 或全为 1 时，代表特殊的值

| 数符  |    阶码     | 尾数  |   数值    |
| :---: | :---------: | :---: | :-------: |
|   0   |      0      |   0   |    $0$    |
|   1   |      0      |   0   |   $-0$    |
|   0   | 11$\cdots$1 |   0   | $\infty$  |
|   1   | 11$\cdots$1 |   0   | $-\infty$ |

引入无穷大是为了在计算出现异常时程序能够进行

#### 定点、浮点的区别

1. 表示范围：相同字长下，浮点数的表示范围远大于定点数
2. 精度：浮点数精度较低
3. 运算：浮点数的运算包括尾数和阶码，还要求规格化，因此运算更为复杂
4. 溢出：定点数运算结果超出表示范围即说明溢出；浮点数运算结果规格化后超出表示范围才说明溢出

### 浮点数的加减

1. 对阶：使两个数阶码相等。小阶向大阶看齐，尾数右移，阶码 $+1$。尾数右移时舍弃有效位会产生误差
2. 尾数求和：对阶后的尾数做定点数的加减运算
3. [规格化](#浮点数规格化)
4. 舍入：尾数右移时将低位移出，保留移出的两位参与运算，最后进行舍入

   - 0 舍 1 入法：运算结果最高位为 0 则舍去；最高位为 1 则在尾数末位加 1。之后可能需要再次进行右规
   - 恒置 1 法：移出位中有 1 则将尾数末位置 1
   - 截断法：直接截断，丢弃移出位

5. 溢出判断

   - 正指数超过最大值：指数上溢，产生异常。**右规**和**尾数舍入**时需要判断上溢
   - 负指数小于最小值：指数下溢，视作 0。**左规**时需要判断下溢

:memo: 尾数或阶码采用补码表示时通常采用双符号位。尾数求和溢出时（符号位为 01 或 10）需右规一次；求和结果为 $00.0\cdots$ 或 $11.1\cdots$ 时需要左规至 $00.1\cdots$ 或 $11.0\cdots$

### 浮点数类型转换

- int $\to$ float：float 尾数位数共 24 位，int 的 24～31 位非 0 时无法精确转换为尾数，需要舍入
- int/float $\to$ double：可保留精确值
- double $\to$ float：可能发生溢出。需要舍入
- float/double $\to$ int：仅保留整数部分，发生舍入。可能溢出

## 存储系统

### 存储器分类

#### 按作用（层次）分类

1. 主存储器
   : 主存/内存。存放运行时所需的程序和数据。CPU 可直接随机访问，可与 Cache 和辅存交换数据。容量较小、速度较快、成本较高
2. 辅助存储器
   : 辅存/外存。存放暂时不用的程序和数据，以及需要永久保存的信息。CPU 无法直接访问。容量较大、速度较慢、成本较低
3. 高速缓冲存储器
   : Cache。介于主存和 CPU 之间，存放当前 CPU 经常使用的指令和数据。速度可与 CPU 匹配，容量小、价格高。位于 CPU 内

#### 按存储介质分类

1. 磁表面存储器：磁盘、磁带
2. 磁芯存储器
3. 半导体存储器：MOS 型存储器、双极型存储器
4. 光存储器：光盘

#### 按存取方式分类

1. 随机存储器（RAM）
   : 可随机存取，存取时间与物理位置无关。读写方便灵活，主要用作主存和 Cache。分为[静态 RAM](#sram) 和[动态 RAM](#dram)
2. 只读存储器（ROM）
   : 可随机读取，不能写入，断电信息不丢失。通常用作存放固定不变的程序、常数，与 RAM 可共同作为主存的一部分。派生的存储器包含可反复重写的类型
3. 串行访问存储器
   : 读写时需要根据物理位置的先后顺序寻址。包括顺序存取存储器（磁带）、直接存取存储器（磁盘、光盘）

#### 按信息的可保存性分类

1. 易失性存储器
   : 断电后信息丢失。如 RAM
2. 非易失性存储器
   : 断电后信息不丢失。如 ROM、磁表面存储器、光存储器
3. 破坏性读出
   : 读出信息后原存储信息被破坏。每次读出后需要再生
4. 非破坏性读出
   : 读出信息后原存储信息不被破坏

### 存储器性能指标

1. 存储容量
2. 单位成本
3. 存储速度

   1. 存取时间（$T_a$）：启动一次存储器操作到完成该操作。分为读出时间和写入时间
   2. 存取周期（$T_m$）：读写周期/访问周期。进行一次完整操作所需的全部时间，即两次独立访问操作之间的最小时间间隔
   3. 主存带宽（$B_m$）：数据传输速率

   - 存储器在读写操作后需要一段恢复时间，因此存取周期大于存取时间
   - 对于破坏性读出的存储器，存取周期往往比存取时间大得多

### 多级层次存储系统

Cache - 主存 - 辅存  
上层存储器作为下层存储器的高速缓存，存储下层内容的副本  
解决速度、容量、成本之间的矛盾

- 主存和 Cache 之间的数据调动由硬件自动完成，对所有程序员透明
- 主存和辅存之间的数据调动由硬件和操作系统共同完成，对应用程序员透明

### 主存

#### SRAM

静态随机存储器  
存储元使用双稳态触发器（六晶体管 MOS），非破坏性读出  
存取速度快、集成度低、功耗大、成本高  
一般用于 Cache

#### DRAM

动态随机存储器  
存储元使用一个晶体管，利用电路中栅极电容上的电荷存储信息  
存取速度慢、集成密度高、功耗低、成本低、容量大  
一般用于大容量主存

DRAM 电容上的电荷维持时间短，需要每隔一段时间刷新，刷新周期通常为 2ms

1. 集中刷新
   : 在一个刷新周期内，利用一段固定时间（死时间/访存死区），依次对所有行进行逐一再生。读写不受刷新影响，但刷新时不能访问存储器
2. 分散刷新
   : 对每行的刷新分散到各个工作周期中。没有死区，但增加了系统的存取周期
3. 异步刷新
   : 刷新周期除以行数，得到两次刷新的时间间隔 $t$，逻辑电路每隔 $t$ 产生一次刷新请求。避免 CPU 连续等待太长时间，减少刷新次数

- 刷新不依赖于外部的访问
- 刷新单位为行，芯片内部自行生成行地址
- 刷新时不需要选片，所有芯片同时被刷新

#### DRAM 的读写周期

读周期：$\overline{\text{RAS}}$ 有效前送行地址，$\overline{\text{CAS}}$ 滞后一段时间，有效前送列地址。$\overline{\text{WE}}$ 在 $\overline{\text{CAS}}$ 有效前建立高电平  
写周期：送地址同读周期。$\overline{\text{WE}}$ 在 $\overline{\text{CAS}}$ 有效前建立低电平

#### SRAM 和 DRAM 比较

|            |  SRAM  |  DRAM  |
| :--------: | :----: | :----: |
|  存储信息  | 触发器 |  电容  |
| 破坏性读出 |   否   |   是   |
|  需要刷新  |   否   |   是   |
| 送行列地址 |  同时  | 分两次 |
|  运行速度  |   快   |   慢   |
|   集成度   |   低   |   高   |
|  存储成本  |   高   |   低   |
|  主要用途  | Cache  |  主存  |

#### 存储器芯片内部结构

1. 存储体（存储矩阵）
   : 存储单元的集合，由行选择线和列选择线来选择访问的单元。相同行、列上的位同时被读出或写入
2. 地址译码器
   : 将地址转换为译码输出线上的高电平，驱动读写电路
3. I/O 控制电路
   : 控制被选中单元的读出或写入，放大信息
4. 片选控制信号
   : 存储器包含多个芯片，需要选中存储字所在的芯片
5. 读/写控制信号
   : 根据 CPU 给出的命令控制被选中的单元读/写

#### ROM

ROM 中有了信息不能轻易改变，掉电不会丢失  
结构简单，位密度比可读写存储器高  
具有非易失性，可靠性高

#### ROM 的类型

1. 掩模式只读存储器（MROM）
   : 内容在生产过程中直接写入，写入后无法修改。可靠度高，集成度高，价格便宜，灵活性差
2. 一次可编程只读存储器（PROM）
   : 允许用户利用专门的设备写入程序，写入后无法修改
3. 可擦除可编程只读存储器（EPROM）
   : 可对内容进行多次改写。编程次数有限，写入时间较长
4. Flash 存储器
   : 可在不加电的情况下长期保存信息，可在线进行快速擦除重写。价格便宜，集成度高（EPROM），电可擦除重写，擦除重写速度快（E~2~PROM）
5. 固态硬盘（SSD）
   : 由控制单元和存储单元（Flash 芯片）组成。保留 Flash 存储器的特性，相比传统硬盘读写速度快，功耗低，价格较高

#### 主存的基本组成

[结构组成](#存储器芯片内部结构)

1. CPU 把被访问单元的地址送至 MAR
2. 地址线将地址送至主存的地址寄存器
3. 地址译码器选中相应单元
4. 控制线将读写信号送至主存的读写控制电路

   - 读：数据线将选中单元的内容送至 MDR
   - 写：CPU 将信息送至 MDR，数据线将内容写入选中单元

DRAM 采用**地址引脚复用技术**，行列地址通过相同的引脚分两次输入，减少芯片的地址引脚数

#### 多模块存储器

多个结构完全相同的存储模块并行工作，提高吞吐率。空间并行技术

1. 单体多字存储器
   : 存储器中包含一个存储体，每个存储单元存储 $m$ 个字

   一个存取周期内可在**同一地址**取出 $m$ 条指令，逐条送至 CPU。即每隔 $\frac{1}{m}$ 个存储周期，CPU 取一条指令。指令和数据在主存内必须连续存放

2. 多体并行存储器
   : 由多体模块组成。每个模块有相同的容量和存取速度，有独立的读写控制电路、地址寄存器和数据寄存器。可并行工作、交叉工作

   1. 高位交叉编址（顺序方式）：高位表示体号，低位表示体内地址。按顺序访问存储模块，不能并行访问，无法提高吞吐率

      存取周期为 $T$，连续存取 $m$ 个字所需的时间为

      $$ t_1=mT $$

   2. 低位交叉编址（交叉方式）：低位表示体号，高位表示体内地址。有 $m$ 个模块，每个模块按模 $m$ 交叉编址。可采用流水线方式并行存取

      存取周期为 $T$，总线传送周期为 $r$，模块数应大于等于

      $$ m=\frac{T}{r} $$

      $m$ 称为交叉存取度。每经过 $r$ 时间启动下一个模块，模块数大于等于 $m$ 时可保证某模块再次启动时存取已完成（流水线不间断）。连续存取 $m$ 个字所需的时间为

      $$ t_2=T+(m-1)r $$

### 主存与 CPU 的连接

主存通过数据总线、地址总线、控制总线与 CPU 连接

1. 数据总线的位数与工作频率的乘积正比于数据传输速率
2. 地址总线的位数决定了可寻址的最大内存空间
3. 控制总线指出总线周期的类型和本次 I/O 操作完成的时刻

#### 主存容量的扩展

1. 位扩展法
   : CPU 数据线数与存储芯片的数据位数不相等，对存储芯片扩位

   8 片 8K $\times$ 1 位 $\to$ 8K $\times$ 8 位  
   将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出

2. 字扩展法
   : 增加存储器中字的数量，位数不变

   4 片 16K $\times$ 8 位 $\to$ 64K $\times$ 8 位  
   芯片的地址线、数据线、读写控制线相应并联  
   地址高位用作片选信号，区分各芯片的地址范围。同一时间只选中一个芯片

3. 字位同时扩展法
   : 既增加存储字的数量，又增加存储字长

   8 片 16K $\times$ 4 位 $\to$ 64K $\times$ 8 位  
   每 2 片芯片一组，位扩展为 16K $\times$ 8 位；4 组芯片字扩展为 64K $\times$ 8 位

#### 存储芯片的地址分配和片选

CPU 访问存储单元，先片选后字选  
字选由 CPU 的低位地址线完成  
片选信号产生分为线选法和译码片选法

1. 线选法
   : 高位地址线直接连接各个芯片片选端，$n$ 条地址线片选 $n$ 个芯片。地址线信号为 0 时选中对应芯片

   :+1: 不需要地址译码器，线路简单  
   :-1: 地址空间不连续，不能充分利用存储器空间，浪费地址资源

2. 译码片选法
   : 高位地址线通过地址译码器芯片产生片选信号，$n$ 条地址线片选 $2^n$ 个芯片

#### 存储器与 CPU 的连接

1. 合理选择存储芯片
2. 地址线的连接
3. 数据线的连接
4. 读/写命令线的连接
5. 片选线的连接

### 外存

#### 磁盘

- 存储容量大，位价格低
- 记录介质可重复使用
- 信息可长期保存，可脱机存档
- 非破坏性读出
- 存取速度慢，机械结构复杂，工作环境要求高

组成

- 磁盘驱动器：磁头组件，盘片组件
- 磁盘控制器：硬盘和主机的接口，IDE/SCSI/SATA
- 盘片

  - 磁头数
    : 记录面数，一个记录面对应一个磁头
  - 柱面数
    : 每面盘片上的磁道数，不同记录面上同位置的磁道构成一个圆柱面
  - 扇区数
    : 扇区（块）读写的最小单位

通过电磁转换完成读/写，采用调频制（FM）和改进调频制（MFM）的记录方式

性能指标

- 记录密度：单位面积上的二进制信息量

  - 道密度
    : 磁盘半径方向单位长度上的磁道数
  - 位密度
    : 磁道单位长度上的二进制位数
  - 面密度
    : 道密度 $\times$ 位密度

- 磁盘容量

  - 非格式化容量
    : 磁记录表面可利用的磁化单元总数，由道密度和位密度计算而来
  - 格式化容量
    : 按照某种特定记录格式可存储信息的总量，小于非格式化容量

- 平均存取时间：寻道时间 + 旋转延迟时间 + 传输时间

  - 寻道时间：磁头移动至目标磁道
  - 旋转延迟时间：磁头定位到目标扇区
  - 传输时间：传输数据花费的时间

- 数据传输率：单位时间传输的字节数

  磁盘转速为 $r$ 转/秒，每条磁道容量为 $N$ Byte，数据传输率为

  $$ D_r=rN $$

磁盘地址组成：{ 驱动器号 | 柱面（磁道）号 | 盘面号 | 扇区号 }  
取控制字 $\to$ 执行控制字  
硬盘读写操作是串行的，不能同时读写或同时操作多组数据

##### 磁盘阵列（RAID）

多个独立的物理磁盘组成一个独立的逻辑盘，具有更好的存储性能、可靠性、安全性

- RAID 0：无冗余无校验，连续多个数据块交替存放于不同物理磁盘，交叉并行读写
- RAID 1：镜像，两个磁盘同时读写，互为备份
- RAID 2：纠错海明码
- RAID 3：位交叉奇偶校验
- RAID 4：块交叉奇偶校验
- RAID 5：无独立校验的奇偶校验

磁盘并行提高传输率和数据吞吐量，镜像功能提高安全可靠性，数据校验提供容错能力

#### 固态硬盘

一个或多个闪存芯片 + 闪存翻译层  
闪存由块组成，块由页组成  
数据以页为单位读写  
擦除以块为单位

- 随机访问性能好
- 无移动机械结构，能耗低，抗震性好，安全性高
- 闪存块擦除寿命有限

### Cache

#### 局部性原理

- 时间局部性
- 空间局部性

#### Cache 工作原理

Cache 通常由 [SRAM](#sram) 构成  
Cache 和主存都被划分为相等的块，Cache 块又称 Cache 行

1. CPU 发出请求时，若 Cache 命中则将地址转换成 Cache 地址，直接对 Cache 进行操作
2. 若 Cache 不命中，仍需访问主存，并把所在的块一次性调入 Cache
3. 若 Cache 已满，需要根据替换算法替换原有的块

- Cache 操作全部由硬件实现
- CPU - Cache 数据交换以字为单位，Cache - 主存数据交换以 Cache 块为单位
- 某些计算机同时访问 Cache 和主存，Cache 命中则终止主存访问

Cache 命中率：CPU 欲访问的信息已在 Cache 中的比率  
Cache 命中次数为 $N_c$，主存访问次数为 $N_m$，命中率 $H$ 为

$$ H=\frac{N_c}{N_c+N_m} $$

Cache 命中时的访问时间为 $t_c$，未命中时的访问时间为 $t_m$，平均访问时间 $T_a$ 为

$$ T_a=Ht_c+(1-H)t_m $$

#### Cache - 主存映射方式

Cache 中每块添加一个标记（tag），指明是主存中哪一块的副本  
每个 Cache 行需要一个**有效位**，说明信息是否有效

1. 直接映射
   : 主存中每一块装入 Cache 中唯一位置，无需使用替换算法

   主存块号为 $i$，Cache 行号为 $j$，Cache 共有 $2^c$ 行

   $$ j=i\bmod2^c $$

   - 主存块号的低 $c$ 位就是 Cache 行号
   - 设主存块号长为 $m$，每个 Cache 行的 tag 长为 $t=m-c$，记录主存块号的高 $t$ 位
   - 地址结构：{ 标记 | Cache 行号 | 块内地址 }

   1. 根据访存地址中间 $c$ 位找到 Cache 行，高 $t$ 位与该行 tag 比较，相等且有效位为 1 则命中
   2. 若不命中则从主存读出块信息送入对应 Cache 行，有效位置 1，tag 置为地址高 $t$ 位，内容送 CPU

   :+1: 实现简单  
   :-1: 不够灵活，冲突率最高，空间利用率最低

2. 全相联映射
   : 主存中每一块可以装入 Cache 中任何位置，使用标记指明主存中的块

   - 访存时需要和所有 Cache 行的标记进行比较
   - 每个 Cache 行 tag 长 $m$（即主存块号）
   - 地址结构：{ 标记 | 块内地址 }

   :+1: 较为灵活，冲突率低，命中率高，空间利用率高  
   :-1: 标记速度较慢，实现成本较高

3. 组相联映射
   : Cache 空间分成大小相同的组，主存块可以装入一组内的任一位置。组间直接映射，组内全相联映射

   主存块号为 $i$，Cache 行的组号为 $j$，Cache 共有 $Q$ 组

   $$ j=i\bmod Q $$

   - 每组有 $r$ 个 Cache 行，称为 $r$ 路组相联
   - $r$ 越大，冲突概率越低，电路越复杂
   - $Q=1$ 即全相联映射，$Q=2^c$ 即直接映射
   - 地址结构：{ 标记 | 组号 | 块内地址 }

   1. 根据访存地址中间的组号找到 Cache 组
   2. 地址高位与该组每行的 tag 比较，若有相等且有效位为 1 则命中
   3. 若不命中则从主存读出块信息送入对应 Cache 组的任意空闲行，有效位置 1，tag 置为地址高位，内容送 CPU

#### Cache 替换算法

1. 随机（RAND）
   : 随机确定替换的行。实现简单，未依据局部性原理，命中率较低
2. 先进先出（FIFO）
   : 替换最早调入的行。实现较容易，未依据局部性原理
3. 近期最少使用（LRU）
   : 替换最长未访问的行。依据局部性原理，平均命中率高于 FIFO。堆栈类算法

   1. 对每个 Cache 行设置计数器，记录使用情况。位数为 $\log_2r$ bit
   2. 命中时，命中行的计数器置 $0$，比其低的计数器 $+1$
   3. 未命中且有空行时，新行的计数器置 $0$，其余所有计数器 $+1$
   4. 未命中且无空行时，替换计数器最大（$r-1$）的行，新行的计数器置 $0$，其余所有计数器 $+1$

   - 抖动：集中访问的块数超过 Cache 组的大小，导致命中率极低

4. 最不经常使用（LFU）
   : 替换一段时间内访问次数最少的行

   每行设置计数器，从 $0$ 开始计数，被访问的行计数器 $+1$，无空行时替换计数器最小的行

#### Cache 写策略

Cache 中的内容更新时需要写操作使主存内容与 Cache 保持一致

- 写命中

  1. 全写法（写直通法，write-through）
     : 写命中时把数据同时写入 Cache 和主存，替换时直接覆盖

     :+1: 实现简单，时刻保持主存内容正确  
     :-1: 增加了访存次数，降低 Cache 的效率，需要设置写缓冲（Write Buffer）

  2. 写回法（回写法，write-back）
     : 写命中时只修改 Cache 的内容，当块被换出时写回主存

     :+1: 减少了访存次数  
     :-1: 存在不一致的隐患，需要在 Cache 行设置一个修改位（脏位），修改位为 1 说明内容被修改过

- 写不命中

  1. 写分配法（write-allocate）
     : 加载主存块到 Cache 中，更新该 Cache 行

     每次不命中都需要从主存中读取一块

  2. 非写分配法（non-write-allocate）
     : 不调块，直接写入主存

非写分配法 搭配 全写法  
写分配法 搭配 写回法

统一 Cache 结构：设计实现简单；会引发冲突  
分离 Cache 结构：指令 Cache 和数据 Cache 分开设计。解决冲突问题，易于优化性能

多级 Cache：CPU - L1 - L2 - L3  
指令 Cache 和数据 Cache 分离在 L1，使用写分配法和写回法

### 虚拟存储器

见[操作系统-内存管理](./OperatingSystem.md#内存管理)

将主存或辅存统一编址  
虚地址（逻辑地址） - 虚拟空间（程序空间）  
实地址（物理地址） - 主存地址空间（实地址空间）

- 虚地址大于实地址
- 虚拟存储器类似 Cache，将辅存中经常访问的数据存放在内存中
- 采用**全相联映射**和**写回法**

#### 页式

虚拟空间和主存空间被划分为同样大小的**页**  
主存的页称为实页（页框）（Page Frame），虚存的页称为虚页（Page）  
虚拟地址结构：{ 虚页号 | 页内地址 }

:+1: 页的长度固定，页表简单，调入方便  
:-1: 产生内部碎片，页逻辑上不独立，不易处理、保护、共享

##### 页表

虚页号和实页号的对照表  
存放于主存  
页表基址寄存器存放进程的页表首地址

- 表项组成：{ 有效位 | 脏位 | 引用位 | 物理页号 }
- 有效位（装入位）：表示对应页面是否在主存
- 脏位（修改位）：表示页面是否被修改过（因使用写回法）
- 引用位（使用位）：配合替换策略进行设置

1. 根据页表首地址访问页表
2. 根据虚拟地址高位的虚页号找到对应页表项
3. 若装入位为 1，物理页号与低位页内地址拼接，得到物理地址
4. 若装入位为 0，执行缺页处理

##### 快表（Translation Lookaside Buffer, TLB）

经常访问的页表项  
通常由相联存储器构成  
采用**全相联映射**或**组相联映射**

CPU 访存可能出现三种缺失

1. TLB 缺失
   : 页表项不在 TLB 中。需要访问一次主存。可由硬件或软件处理
2. Page 缺失
   : 页面不在主存中。需要访问磁盘。由软件处理
3. Cache 缺失
   : 主存块不在 Cache 中。需要访问一次主存。由硬件处理

- TLB 命中则 Page 一定命中
- Page 缺失则 Cache 一定缺失

|  TLB  | Page  | Cache |
| :---: | :---: | :---: |
|  :o:  |  :o:  |  :o:  |
|  :o:  |  :o:  |  :x:  |
|  :x:  |  :o:  |  :o:  |
|  :x:  |  :o:  |  :x:  |
|  :x:  |  :x:  |  :x:  |

#### 段式

**段**按程序的逻辑结构划分  
虚拟地址结构：{ 段号 | 段内地址 }  
段表基址寄存器存放段表首地址  
段表项组成：{ 段首址 | 装入位 | 段长 }

1. 段表首地址与段号拼接得到对应段表行
2. 若装入位为 1，段起始地址与段内地址拼接，得到物理地址

:+1: 具有逻辑独立性，易于编译、管理、修改、保护，以及程序间共享  
:-1: 段长度可变，分配空间不便，产生外部碎片

#### 段页式

程序按逻辑结构分段，每段划分为固定大小的页，主存也划分为页  
每个程序对应一个段表，每段对应一个页表  
段长为页长的整数倍，段的起点为某一页的起点  
虚拟地址结构：{ 段号 | 段内页号 | 页内地址 }

:+1: 兼顾页式和段式的优点，可按段实现共享和保护  
:-1: 地址变换过程中需要两次查表，系统开销较大

### Cache 与虚拟存储器对比

- 相同

  1. 提高系统性能
  2. 将数据划分为小信息快作为基本单位
  3. 有相应的地址映射、替换算法、更新策略
  4. 依据局部性原理

- 不同

  1. Cache 解决系统速度，虚拟存储器解决主存容量
  2. Cache 全由硬件实现，是硬件存储器；虚拟存储器由 OS 和硬件共同实现，是逻辑存储器
  3. 虚拟存储器不命中时对系统性能影响更大
  4. Cache 不命中时主存可以和 CPU 直接通信；虚拟存储器不命中时辅存无法和 CPU 直接通信

## 指令系统

指令系统位于硬件和软件的交界面上

### 指令基本格式

指令结构：{ 操作码字段 | 地址码字段 }

- 指令长度与机器字长没有固定关系。单字长指令/半字长指令/双字长指令
- 指令字长多为字节整数倍
- 定长指令字结构
  : 所有指令的长度相等。执行速度快，控制简单
- 变长指令字结构
  : 指令长度随指令功能而异

#### 零地址指令

$\text{OP}$

1. 不需要操作数的指令：空操作指令、停机指令、关中断指令
2. 运算类指令：用于堆栈计算机，操作数隐含地从栈顶和次栈顶弹出，运算结果压入堆栈

#### 一地址指令

$\text{OP}|\text{A}_1$

1. 单操作数指令：按 $\text{A}_1$ 地址读操作数，操作结果存回原地址

   $\text{OP}(\text{A}_1)\to\text{A}_1$

2. 双操作数指令：隐含另一操作数由 ACC 提供，运算结果存回 ACC

   $(\text{ACC})\text{OP}(\text{A}_1)\to\text{ACC}$

#### 二地址指令

$\text{OP}|\text{A}_1|\text{A}_2$

$(\text{A}_1)\text{OP}(\text{A}_2)\to\text{A}_1$

两个操作数为目的操作数和源操作数，结果保存于目的操作数的地址

#### 三地址指令

$\text{OP}|\text{A}_1|\text{A}_2|\text{A}_3$

$(\text{A}_1)\text{OP}(\text{A}_2)\to\text{A}_3$

#### 四地址指令

$\text{OP}|\text{A}_1|\text{A}_2|\text{A}_3|\text{A}_4$

$(\text{A}_1)\text{OP}(\text{A}_2)\to\text{A}_3$

$\text{A}_4$ 为下一条将要执行指令的地址

#### 定长操作码

指令字最高位部分分配固定若干位表示操作码。简化硬件设计，提高指令译码和识别速度  
计算机字长为 32 位或更长时的常规用法

#### 扩展操作码

操作码长度可变  
丰富指令种类；增加译码和分析的难度  
操作码的长度随地址码的减少而增加

- 短码不能是长码的前缀
- 操作码不能重复
- 通常为频率较高的指令分配较短的操作码，频率较低的指令分配较长的操作码

### 指令操作类型

1. 数据传送

   寄存器之间的传送 MOV，内存到寄存器 LOAD，寄存器到内存 STORE

2. 算术和逻辑运算

   加 ADD，减 SUB，比较 CMP，乘 MUL，除 DIV，加 1 INC，减 1 DEC，与 AND，或 OR，取反 NOT，异或 XOR

3. 移位操作

   算术移位，逻辑移位，循环移位

4. 转移操作

   无条件转移 JMP，条件转移 BRANCH，调用 CALL，返回 RET，陷阱 TRAP  
   调用指令需要保存下一条指令的地址（返回地址），转移指令不返回

5. 输入输出操作

   CPU 与外部设备交换数据，传送控制命令及状态信息

### 指令寻址

寻找下一条执行的指令地址

1. 顺序寻址
   : PC 加 1 自动形成下一条指令的地址
2. 跳跃寻址
   : 由本条指令给出下条指令地址。跳跃地址分为绝对地址和相对地址（相对当前指令地址的偏移量）。当前指令修改 PC 值，下一条指令仍由 PC 给出

### 数据寻址

寻找本条指令的数据地址

形式地址 $\text{A}$  
有效地址 $\text{EA}$

- 在指令字中设置特征字段区别各种寻址方式
- 指令格式：{ 操作码 | 寻址特征 | 形式地址 }

1. 隐含寻址
   : 不显式给出操作数地址

   :+1: 能缩短指令字长  
   :-1: 需增加存储操作数或隐含地址的硬件

2. 立即（数）寻址
   : 地址字段直接给出操作数本身，补码表示

   :+1: 执行时不访存，执行时间短  
   :-1: 位数限制立即数的范围

3. 直接寻址
   : 形式地址为操作数的真实地址，$\text{EA}=\text{A}$

   :+1: 执行时仅一次访存，无需计算地址  
   :-1: 位数限制操作数寻址范围，地址不易修改

4. 间接寻址
   : 形式地址给出操作数地址的地址，可一次或多次间接寻址，$\text{EA}=(\text{A})$

   :+1: 扩大寻址范围，便于编制程序，完成子程序返回  
   :-1: 需要多次访存，速度慢，**不常用**。扩大寻址范围通常指寄存器间接寻址

5. 寄存器寻址
   : 形式地址给出操作数所在寄存器编号，$\text{EA}=\text{R}_i$

   :+1: 执行时不访存，速度快  
   :-1: 寄存器成本高，数量有限

6. 寄存器间接寻址
   : 形式地址给出操作数主存地址所在的寄存器编号，$\text{EA}=(\text{R}_i)$

   比间接寻址快，需要访存

7. 相对寻址
   : 形式地址给出有效地址相对当前指令地址的位移量，补码表示，$\text{EA}=(\text{PC})+\text{A}$

   操作数地址不固定，便于程序浮动，广泛用于转移指令

8. 基址寻址
   : 基址寄存器内容加上形式地址得到有效地址，$\text{EA}=(\text{BR})+\text{A}$

   面向操作系统，基址寄存器内容不变，形式地址可变  
   基址寄存器位数大于形式地址位数，因此可以扩大寻址范围，适合多道程序设计，可用于编制浮动程序

9. 变址寻址
   : 变址寄存器内容加上形式地址得到有效地址，$\text{EA}=(\text{IX})+\text{A}$

   面向用户，变址寄存器内容可变，形式地址不变  
   扩大寻址范围，适合编制循环程序

10. 堆栈寻址
    : 用于堆栈计算机，操作数地址由堆栈指针 SP 隐式给出

|      寻址方式      |             有效地址             | 访存次数 |
| :----------------: | :------------------------------: | :------: |
|      隐含寻址      |             程序指定             |    0     |
|      立即寻址      |       $\text{A}$ 即操作数        |    0     |
|      直接寻址      |       $\text{EA}=\text{A}$       |    1     |
|    一次间接寻址    |      $\text{EA}=(\text{A})$      |    2     |
|     寄存器寻址     |      $\text{EA}=\text{R}_i$      |    0     |
| 寄存器一次间接寻址 |     $\text{EA}=(\text{R}_i)$     |    1     |
|      相对寻址      | $\text{EA}=(\text{PC})+\text{A}$ |    1     |
|      基址寻址      | $\text{EA}=(\text{BR})+\text{A}$ |    1     |
|      变址寻址      | $\text{EA}=(\text{IX})+\text{A}$ |    1     |

### 汇编指令

#### 通用寄存器

x86 处理器中有 8 个 32 位寄存器

- EAX
  : 累加器（Accumulator）
- EBX
  : 基地址寄存器（Base Register）
- ECX
  : 计数寄存器（Count Register）
- EDX
  : 数据寄存器（Data Register）
- ESI
  : 变址寄存器（Index Register）
- EDI
  : 变址寄存器（Index Register）
- EBP
  : 堆栈基指针（Base Pointer）
- ESP
  : 堆栈顶指针（Stack Pointer）

EAX、EBX、ECX、EDX 的高两位字节和低两位字节可以独立使用  
EAX 的低两位字节为 AX，AX 的高低字节 AH、AL 可作为 8 位寄存器  
寄存器的用途较任意（除 EBP、ESP 外）

#### 条件码（标志位）寄存器

- CF
  : 进（借）位标志。最近无符号整数加/减运算后的进（借）位情况
- ZF
  : 零标志。最近的运算结果是否为 0
- SF
  : 符号标志。最近带符号运算结果的符号
- OF
  : 溢出标志。最近带符号运算结果是否溢出

#### 汇编指令格式

|              |            AT&T            |            Intel            |
| :----------: | :------------------------: | :-------------------------: |
|  字母大小写  |            小写            |        大小写不敏感         |
|  操作数顺序  |   源操作数 - 目的操作数    |    目的操作数 - 源操作数    |
|     前缀     | 寄存器前缀 %，立即数前缀 $ |           无前缀            |
|   内存寻址   |          使用 ( )          |          使用 [ ]           |
|   复杂寻址   |   disp(base,index,scale)   |   [base+index*scale+disp]   |
| 指定数据长度 |           b/w/l            | byte ptr/word ptr/dword ptr |

#### 常用汇编指令（Intel 格式）

- 数据传送

  1. mov
     : 将第二个操作数复制到第一个操作数。不能用于从内存复制到内存

     ```arm
     mov <reg>,<reg>
     mov <reg>,<mem>
     mov <mem>,<reg>
     mov <reg>,<con>
     mov <mem>,<con>
     ```

  2. push
     : 将操作数压入栈。**栈增长方向与内存地址增长方向相反**，压栈前 ESP 减 4，操作数压入 ESP 所示地址

     ```arm
     push <reg32>
     push <mem>
     push <con32>
     ```

  3. pop
     : 出栈，数据送入目的地址。ESP 所示地址的内容出栈，ESP 加 4

     ```arm
     pop <reg32>
     pop <mem>
     ```

- 算术和逻辑运算

  1. add/sub
     : 两个操作数相加/减，结果保存至第一个操作数

     ```arm
     add <reg>,<reg> / sub <reg>,<reg>
     add <reg>,<mem> / sub <reg>,<mem>
     add <mem>,<reg> / sub <mem>,<reg>
     add <reg>,<con> / sub <reg>,<con>
     add <mem>,<con> / sub <mem>,<con>
     ```

  2. inc/dec
     : 操作数自增/自减 1

     ```arm
     inc <reg> / dec <reg>
     inc <mem> / dec <mem>
     ```

  3. imul
     : 带符号整数乘法

     1. 两个操作数：$\text{A}_1\times\text{A}_2\to\text{A}_1$。$\text{A}_1$ 必须为寄存器
     2. 三个操作数：$\text{A}_2\times\text{A}_3\to\text{A}_1$。$\text{A}_1$ 必须为寄存器

     ```arm
     imul <reg32>,<reg32>
     imul <reg32>,<mem>
     imul <reg32>,<reg32>,<con>
     imul <reg32>,<mem>,<con>
     ```

  4. idiv
     : 带符号整数除法。一个操作数为除数，被除数为 64 位 edx:eax，商送至 eax，余数送至 edx

     ```arm
     idiv <reg32>
     idiv <mem>
     ```

  5. and/or/xor
     : 两个操作数与/或/异或，结果保存至第一个操作数

     ```arm
     and <reg>,<reg> / or <reg>,<reg> / xor <reg>,<reg>
     and <reg>,<mem> / or <reg>,<mem> / xor <reg>,<mem>
     and <mem>,<reg> / or <mem>,<reg> / xor <mem>,<reg>
     and <reg>,<con> / or <reg>,<con> / xor <reg>,<con>
     and <mem>,<con> / or <mem>,<con> / xor <mem>,<con>
     ```

  6. not
     : 位翻转指令。将操作数中的每一位取反

     ```arm
     not <reg>
     not <mem>
     ```

  7. neg
     : 取负

     ```arm
     neg <reg>
     neg <mem>
     ```

  8. shl/shr
     : 逻辑左/右移。第一个为被操作数，第二个为移位的位数

     ```arm
     shl <reg>,<con8> / shr <reg>,<con8>
     shl <mem>,<con8> / shr <mem>,<con8>
     shl <reg>,cl / shr <reg>,cl
     shl <mem>,cl / shr <mem>,cl
     ```

- 控制流

  指令指针 IP 在指令执行后自动指向下一条指令。任何指令地址可使用 label 标记

  1. jmp
     : 控制 IP 转移至 label

     ```arm
     jmp <label>
     ```

  2. jcondition
     : 条件转移。依据 [CPU 状态字](#条件码标志位寄存器)（最后一个运算结果）

     ```arm
     je <label>
     jne <label>
     jz <label>
     jg <label>
     jge <label>
     jl <label>
     jle <label>
     ```

  3. cmp/test
     : cmp 比较两个操作数的值（同 sub），test 对两个操作数按位与（同 and）。不保存结果，仅设置 CPU 状态字中的条件码

     ```arm
     cmp <reg>,<reg> / test <reg>,<reg>
     cmp <reg>,<mem> / test <reg>,<mem>
     cmp <mem>,<reg> / test <mem>,<reg>
     cmp <reg>,<con> / test <reg>,<con>
     ```

  4. call/ret
     : 子程序的调用和返回。call 将当前指令地址入栈（保存地址信息），转移至 label；ret 将指令地址出栈，转移至保存的地址

     ```arm
     call <label>
     ret
     ```

### 程序的机器级表示

#### 过程调用

P 调用 Q

1. P 将入口参数（实参）放在 Q 能访问到的地方
2. P 将返回地址存在特定的地方，将控制转移到 Q（`call`）
3. Q 保存 P 的现场，为自己的非静态局部变量分配空间
4. 执行 Q
5. Q 恢复 P 的现场，将返回结果放在 P 能访问到的地方，释放局部变量的空间
6. Q 取出返回地址，将控制转移到 P（`ret`）

使用栈来保存各种数据

#### 选择语句

##### if 语句

通用形式

```c++
if (/* condition */)
{
    /* then */
}
else
{
    /* else */
}
```

goto 语句形式

```c++
    t = /* condition */;
    if (!t)
    {
        goto FALSE;
    }
    /* then */
    goto DONE;
FALSE:
    /* else */
DONE:
```

##### switch 语句

为每一个不同的分支语句设立标签，根据条件的值构造跳转表  
当不同 case 的条件值相差较大时，生成 if-else-if 分段跳转代码，不使用跳转表

#### 循环语句

##### do-while 循环

通用形式

```c++
do
{
    /* body */
} while (/* condition */);
```

goto 语句形式

```c++
LOOP:
    /* body */
    t = /* condition */;
    if (t)
    {
        goto LOOP;
    }
```

##### while 循环

通用形式

```c++
while (/* condition */)
{
    /* body */
}
```

do-while 语句形式

```c++
    t = /* condition */;
    if (!t)
    {
        goto DONE;
    }
    do
    {
        /* body */
    } while (/* condition */);
DONE:
```

进一步，goto 语句形式

```c++
    t = /* condition */;
    if (!t)
    {
        goto DONE;
    }
LOOP:
    /* body */
    t = /* condition */;
    if (t)
    {
        goto LOOP;
    }
DONE:
```

##### for 循环

通用形式

```c++
for (/* init */; /* condition */; /* update */)
{
    /* body */
}
```

while 语句形式

```c++
/* init */
while (/* condition */)
{
    /* body */
    /* update */
}
```

进一步，goto 语句形式

```c++
    /* init */
    t = /* condition */;
    if (!t)
    {
        goto DONE;
    }
LOOP:
    /* body */
    /* update */
    t = /* condition */;
    if (t)
    {
        goto LOOP;
    }
DONE:
```

### CISC 和 RISC

#### 复杂指令系统计算机（CISC）

如 x86 架构

1. 指令系统复杂庞大，指令数目一般 $>200$
2. 指令不定长，格式多，寻址方式多
3. 可以访存的指令不受限制
4. 指令使用频度差别大
5. 指令执行时间差别大，大多数需要多个时钟周期
6. 控制器大多采用微程序控制。有些指令非常复杂，无法使用硬连线控制
7. 难以用优化编译生成高效程序
8. 兼容性强

#### 精简指令系统计算机（RISC）

如 ARM、MIPS 架构

1. 包含使用频率最高的简单指令，复杂指令由简单指令组合实现
2. 指令定长，格式种类少，寻址方式种类少
3. 只有 Load/Store 访存，其余操作在寄存器之间进行
4. 通用寄存器数量多
5. 采用指令流水线技术，大部分指令在一个时钟周期内完成
6. 大多采用硬布线控制，不用/少用微程序控制
7. 重视编译优化，减少程序执行时间
8. 兼容性较差，实用性强

#### CISC 和 RISC 比较

1. RISC 更能利用芯片面积
2. RISC 更能提高运算速度
3. RISC 便于设计，降低成本，提高可靠性
4. RISC 有利于编译程序代码优化

|                | CISC               | RISC                 |
| -------------- | ------------------ | -------------------- |
| 指令系统       | 复杂，庞大         | 简单，精简           |
| 指令数目       | 一般 $>200$        | 一般 $<100$          |
| 指令字长       | 变长               | 定长                 |
| 可访存指令     | 不加限制           | 仅 Load/Store        |
| 执行时间       | 相差很大           | 大多在一个周期内完成 |
| 使用频度       | 相差很大           | 都比较常用           |
| 通用寄存器数量 | 较少               | 多                   |
| 目标代码       | 难以优化编译       | 重视编译优化         |
| 控制方式       | 大多为微程序控制   | 大多为组合逻辑控制   |
| 指令流水线     | 可通过一定方式实现 | 必须实现             |

## 中央处理器

### CPU 的功能

1. 指令控制
   : 完成取指令、分析指令、执行指令，即程序的顺序控制
2. 操作控制
   : 管理并产生指令的操作信号，将信号送往相应部件
3. 时间控制
   : 对操作加以时间上的限制，为每条指令按时间顺序提供应有的控制信号
4. 数据加工
   : 数据的算术和逻辑运算
5. 中断处理
   : 对异常情况和特殊请求进行处理

### CPU 的基本结构

#### 运算器

接收从控制器送来的命令并执行相应的动作，对数据加工和处理，执行算术和逻辑运算

1. 算术逻辑单元（ALU）
   : 进行算术/逻辑运算
2. 暂存寄存器
   : 暂存从主存读来的数据，不能存放在通用寄存器中。对应用程序员透明
3. 累加寄存器（ACC）
   : 通用寄存器，暂存 ALU 运算结果，可作为加法运算的一个输入
4. 通用寄存器组
   : 存放操作数和各种地址信息。见[通用寄存器](#通用寄存器)
5. 程序状态字寄存器（PSW）
   : 保留由算术逻辑运算指令或测试指令的结果建立的各种状态信息。这些位参与并决定微操作的形成。见[状态字寄存器](#条件码标志位寄存器)
6. 移位器
   : 对操作数或运算结果进行移位运算
7. 计数器（CT）
   : 控制乘除运算的操作步数

#### 控制器

执行指令，每条指令由控制器发出一组微操作实现，控制全机协调工作  
有[硬布线控制器](#硬布线控制器组合逻辑控制器)和[微程序控制器](#微程序控制器)两种类型

1. 程序计数器（PC）
   : 存放下一条指令的主存地址。具有自增功能
2. 指令寄存器（IR）
   : 存放当前正在执行的指令
3. 指令译码器
   : 对操作码字段进行译码，向控制器提供特定的操作信号
4. 存储器地址寄存器（MAR）
   : 存放要访问的主存单元地址
5. 存储器数据寄存器（MDR）
   : 存放向主存写入/从主存读出的信息
6. 时序系统
   : 产生各种时序信号，由统一时钟（CLOCK）分频得到
7. 微操作信号发生器
   : 根据 IR、PSW 的内容及时序信号，产生控制计算机系统的控制信号。结构分为组合逻辑型和存储逻辑型

:memo: CPU 内部寄存器大致可分为两类

- 用户可见，可编程：通用寄存器组、PSW
- 用户不可见，不可编程：MAR、MDR、IR

### 指令执行过程

#### 指令周期

CPU 从主存取出并执行一条指令的时间

- 不同指令的指令周期可能不同
- 指令周期包含若干机器周期，机器周期包含若干时钟周期（节拍/$T$ 周期）
- 指令周期内机器周期数可以不同，机器周期内时钟周期数可以不同

一个完整的指令周期包括：取指周期 | 间址周期 | 执行周期 | 中断周期  
对应 CPU 内 4 个标志触发器：FE、IND、EX、INT，1 表示有效

1. 取指周期
   : 根据 PC 的内容从主存取出指令代码并存放在 IR 中。取指令同时 PC 加 1

   PC $\to$ MAR $\to$ 地址总线 $\to$ 主存  
   CU 读命令 $\to$ 控制总线 $\to$ 主存  
   主存 $\to$ 数据总线 $\to$ MDR $\to$ IR  
   CU 控制信号 $\to$ (PC) + 1

2. 间址周期
   : 取操作数有效地址

   Ad(IR) $\to$ MAR $\to$ 地址总线 $\to$ 主存  
   CU 读命令 $\to$ 控制总线 $\to$ 主存  
   主存 $\to$ 数据总线 $\to$ MDR

3. 执行周期
   : 取操作数，根据 IR 中的指令通过 ALU 操作产生执行结果
4. 中断周期
   : 处理中断请求。程序断点存入堆栈，先修改栈顶指针，后存入数据

   CU 控制信号 $\to$ (SP) - 1，SP $\to$ MAR $\to$ 地址总线 $\to$ 主存  
   CU 写命令 $\to$ 控制总线 $\to$ 主存  
   PC $\to$ MDR $\to$ 数据总线 $\to$ 主存  
   CU 中断服务程序入口地址 $\to$ PC

   :memo: 只在出现中断请求时才会进入中断周期

#### 指令执行方案

1. 单指令周期
   : 所有指令选用相同的执行时间完成

   - 每条指令在固定的时钟周期内完成
   - 指令串行执行
   - 指令周期取决于执行时间最长的指令，会降低整个系统的速度

2. 多指令周期
   : 不同类型的指令选用不同的执行步骤

   - 可选用不同的时钟周期数完成不同的指令
   - 指令串行执行

3. 流水线方案
   : 指令之间可以并行执行

   - 力争在每个时钟周期完成一条指令的执行（理想情况）
   - 在每个时钟周期启动一条指令，尽量让多条指令并行，各自处于不同的执行步骤

### 数据通路

数据在功能部件之间传送的路径（包括流经的部件）称为**数据通路**  
数据通路由控制部件控制，控制部件生成对数据通路的控制信号  
数据通路的功能：实现 CPU 内部的运算器与寄存器，以及寄存器之间的数据交换

#### 数据通路的基本结构

1. CPU 内部单总线方式
   : 所有寄存器的输入端和输出端连接到一条公共通路上

   :+1: 结构简单  
   :-1: 存在较多的冲突现象，性能较低，一个时钟周期内只允许传送一个数据

2. CPU 内部三总线方式
   : 所有寄存器的输入端和输出端连接到多条公共通路上

   多总线方式可同时在多个总线上传送不同数据，提高效率

3. 专用数据通路方式
   : 根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线

   :+1: 性能较高  
   :-1: 硬件量大

:memo: **内部总线**指一个部件内部连接各子部件的总线；**系统总线**指一台计算机系统中连接各部件的总线

#### 数据传送过程

##### 寄存器之间的数据传送

通过 CPU 内部总线完成

例：PC 内容送至 MAR

$\text{PC}\to\text{Bus}$（PCout 有效）  
$\text{Bus}\to\text{MAR}$（MARin 有效）

##### 主存与 CPU 之间的数据传送

需要借助 CPU 内部总线

例：CPU 从主存读取指令

$\text{PC}\to\text{Bus}\to\text{MAR}$（PCout 和 MARin 有效）  
$1\to\text{R}$（CU 读命令）  
$\text{M}(\text{MAR})\to\text{MDR}$（MDRin 有效）  
$\text{MDR}\to\text{Bus}\to\text{IR}$（MDRout 和 IRin 有效）

##### 执行算术或逻辑运算

加法运算时，两个数须在 ALU 的两个输入端同时有效。使用暂存器 Y 保存一个操作数，另一个操作数经总线直接送至 ALU。结果暂存于暂存器 Z

$\text{Ad}(\text{IR})\to\text{Bus}\to\text{MAR}$（MDRout 和 MARin 有效）  
$1\to\text{R}$（CU 读命令）  
$\text{M}\to\text{MDR}$（MDRin 有效）  
$\text{MDR}\to\text{Bus}\to\text{Y}$（MDRout 和 Yin 有效）  
$(\text{ACC})+(\text{Y})\to\text{Z}$（ACCout 和 ALUin 有效，CU 向 ALU 发加命令）  
$\text{Z}\to\text{ACC}$（Zout 和 ACCin 有效）

### 控制器工作原理

- 运算器部件 $\xrightarrow{\text{数据}}$ 数据总线 $\xrightarrow{\text{数据}}$ 内存/输入设备/输出设备
- 输入设备/输出设备 $\xleftrightarrow{\text{接口电路}}$ 总线
- 地址总线 $\xrightarrow{\text{地址信息}}$ 内存/输入设备/输出设备
- 控制总线 $\xrightarrow{\text{控制信号}}$ 内存/输入设备/输出设备
- 数据总线 $\xleftrightarrow{\text{数据}}$ 内存/输入设备/输出设备
- 数据总线 $\xrightarrow{\text{指令信息}}$ 控制器部件
- 运算器部件 $\xrightarrow{\text{指令转移地址}}$ 控制器部件
- 控制器部件 $\xrightarrow{\text{指令地址}}$ 地址总线
- 控制器部件 $\xrightarrow{\text{控制信号}}$ 系统中的部件

控制器的主要功能

- 从主存中取出一条指令，并指出下一条指令的地址
- 对指令译码/测试，产生相应的操作控制信号，以启动规定的动作
- 指挥并控制 CPU、主存、输入和输出设备之间的数据流动方向

#### 硬布线控制器（组合逻辑控制器）

由组合逻辑门电路和触发器构成  
根据指令要求、当前时序、外部内部状态，按时间顺序发送一系列微操作控制信号

##### CU 输入信号来源

1. 指令译码器译码产生的指令信息

   指令操作码字段作为输入信号，与时钟配合产生不同的控制信号

2. 时序系统产生的机器周期信号和节拍信号

   一个时钟脉冲使控制单元发送一个操作命令，或一组需要同时执行的操作命令

3. 执行单元的反馈信息，即标志

   控制单元有时依赖 CPU 当前所处的状态产生控制信号

:memo: 控制单元还接收来自系统控制总线的控制信号，如中断请求、DMA 请求

##### 硬布线控制器的时序系统

1. 时钟周期：时钟信号控制节拍发生器产生节拍，对应一个时钟周期。可完成一个或几个需同时执行的操作
2. 机器周期：可视为所有指令执行过程中的基准时间。通常以取存周期作为基准时间。取指周期也可视为机器周期（存储字长等于指令字长时）
3. [指令周期](#指令周期)
4. 微操作命令分析：控制单元可发出各种操作命令（控制信号）序列。须按一定次序发出

指令周期中的微操作命令

1. 取指周期

   $\text{PC}\to\text{MAR}$  
   $1\to\text{R}$  
   $\text{M}(\text{MAR})\to\text{MDR}$  
   $\text{MDR}\to\text{IR}$  
   $\text{OP}(\text{IR})\to\text{CU}$  
   $(\text{PC})+1\to\text{PC}$

2. 间址周期

   $\text{Ad}(\text{IR})\to\text{MAR}$  
   $1\to\text{R}$  
   $\text{M}(\text{MAR})\to\text{MDR}$

3. 执行周期

   微操作命令视不同指令而定

   - 非访存指令

     `CLA`  
     $0\to\text{ACC}$  
     `COM`  
     $\overline{\text{ACC}}\to\text{ACC}$  
     `SHR`  
     $\text{L}(\text{ACC})\to\text{R}(\text{ACC})$  
     $\text{ACC}_0\to\text{ACC}_0$  
     `CSL`  
     $\text{L}(\text{ACC})\to\text{R}(\text{ACC})$  
     $\text{ACC}_0\to\text{ACC}_n$  
     `STP`  
     $0\to\text{G}$

   - 访存指令

     `ADD X`  
     $\text{Ad}(\text{IR})\to\text{MAR}$  
     $1\to\text{R}$  
     $\text{M}(\text{MAR})\to\text{MDR}$  
     $(\text{ACC})+(\text{MDR})\to\text{ACC}$  
     `STA X`  
     $\text{Ad}(\text{IR})\to\text{MAR}$  
     $1\to\text{W}$  
     $\text{ACC}\to\text{MDR}$  
     $\text{MDR}\to\text{M}(\text{MAR})$  
     `LDA X`  
     $\text{Ad}(\text{IR})\to\text{MAR}$  
     $1\to\text{R}$  
     $\text{M}(\text{MAR})\to\text{MDR}$  
     $\text{MDR}\to\text{ACC}$

   - 转移指令

     `JMP X`  
     $\text{Ad}(\text{IR})\to\text{PC}$  
     `BAN X`  
     $A_0\times\text{Ad}(\text{IR})+\overline{A_0}\times(\text{PC})\to\text{PC}$

##### CPU 的控制方式

1. 同步控制方式
   : 所有控制信号来自统一的时钟信号，以最长的微操作序列为标准，采取相同的节拍数作为机器周期

   :+1: 控制电路简单  
   :-1: 运行速度慢

2. 异步控制方式
   : 各部件按自身固有的速度工作，通过应答方式进行联络

   :+1: 运行速度快  
   :-1: 控制电路较复杂

3. 联合控制方式
   : 折中方法。对不同指令大部分采用同步控制，小部分采用异步控制

##### 硬布线控制单元设计

1. 列出微操作命令的操作时间表，包括各个机器周期、节拍下的每条指令完成的微操作控制信号
2. 进行微操作信号综合，可写出各微操作信号的逻辑表达式，一般包括

   $$ \text{机器周期}\land\text{节拍}\land\text{脉冲}\land\text{操作码}\land\text{机器状态条件} $$

3. 根据逻辑表达式可画出各微操作信号的逻辑电路图

#### 微程序控制器

指令编写为微程序，微程序包含若干微指令，微指令对应一个或几个微操作  
微程序存储在控制存储器中  
大多数计算机采用微程序设计技术

- 微命令与微操作
  : 指令可分解为微操作序列。微操作最基本，不可分解
    控制部件向执行部件发出的控制命令为微命令。构成控制序列的最小单位

  - 微命令和微操作一一对应
  - 微命令有相容性和互斥性

- 微指令与微周期
  : 微指令是若干微命令的集合
    微周期指从控制存储器中读取一条微指令并执行相应微操作所需的时间

  - 存放微指令的控制存储器的单元地址称为微地址
  - 微指令包含：操作控制字段（微操作码字段）产生操作控制信号；顺序控制字段（微地址码字段）产生下一条微指令地址

- 主存与控制存储器
  : 主存存放程序和数据，在 CPU 外，用 RAM 实现
    控制存储器存放微程序，在 CPU 内，用 ROM 实现
- 程序与微程序
  : 程序是指令的有序集合，完成特定的功能
    微程序是微指令的有序集合，完成一条指令的功能

##### 微程序控制器的组成

1. 控制存储器（CM）
   : 存放各指令对应的微程序，由 ROM 构成
2. 微指令寄存器（CMDR, μIR）
   : 存放从 CM 中取出的微指令，位数与微指令字长相等
3. 微地址形成部件
   : 产生初始微地址和后续微地址
4. 微地址寄存器（CMAR, μPC）
   : 存放微地址形成部件送来的微地址

##### 微程序控制器的工作过程

1. 取微指令公共操作。将取指微程序的入口地址（0 号单元）送 CMAR，从 CM 中读出相应微指令送 CMDR。取指微程序执行后，指令就已存入 IR
2. 微地址形成部件根据指令操作码字段产生指令对应的微程序入口地址，送入 CMAR
3. 从 CM 中逐条取出对应的微指令并执行
4. 回到取指微程序的入口地址，完成下一条指令的公共操作

- 取指微程序：将取指令的微命令统一编成一个微程序，负责将指令从主存取至 IR
- 也可编出对应间址周期和中断周期的微程序

:memo: 若共有 $n$ 种指令，则 CM 中微程序数至少为 $n+1$（包括公共取指微程序）；若间址周期和中断周期的微程序也是公共的，则微程序个数为 $n+3$

##### 微指令的编码方式

1. 直接编码（直接控制）
   : 微指令的微命令字段中每位代表一个微命令，1/0 表示选用/不选用

   { 0 | 1 | $\cdots$ | 0 | 1 | 下地址 }

   :+1: 简单直观，执行速度快，操作并行性好  
   :-1: 微指令字长过长，需要 CM 大容量

2. 字段直接编码
   : 微指令的微命令字段分为若干小字段，每段独立编码，每种编码代表一个微命令，各字段编码含义单独定义

   { $a$ | $b$ | $\cdots$ | $c$ | $d$ | 下地址 }

   - 互斥微命令在同一字段，相容微命令在不同字段
   - 每段包含的信息位不能太多，否则会增加译码线路的复杂性和时间
   - 每段留出一个状态（通常为全 0）表示不发出命令

   :+1: 缩短微指令字长  
   :-1: 需要译码，比直接编码慢

3. 字段间接编码（隐式编码）
   : 一个字段的某些微命令需要另一个字段中的某些微命令解释，不靠字段直接译码

   :+1: 进一步缩短微指令字长  
   :-1: 削弱了并行控制能力。通常作为字段直接编码的辅助手段

##### 微指令的地址形成方式

1. 微指令设置下地址字段，直接指出后继微指令的地址。又称**断定方式**
2. 微地址形成部件根据指令操作码字段形成地址

- 增量计数器法，$(\text{CMAR})+1\to\text{CMAR}$，适用于后继微指令地址连续时
- 根据标志决定微指令分支转移的地址
- 通过测试网络形成
- 由硬件直接产生微程序入口地址

##### 微指令的格式

1. 水平型微指令
   : 基本格式：{ $\text{A}_1$ | $\text{A}_2$ | $\cdots$ | $\text{A}_{n-1}$ | $\text{A}_n$ | 判断测试字段 | 后继地址字段 }

   - $\text{A}_1$ ~ $\text{A}_n$ 为**操作控制字段**，判断测试字段 ~ 后继地址字段为**顺序控制字段**
   - 指令字中一位对应一个控制信号
   - 一条微指令定义并执行几种并行的基本操作
   - [上述编码方式](#微指令的编码方式)均属于水平型微指令

   :+1: 微程序短，执行速度快  
   :-1: 微指令长，编写程序麻烦

2. 垂直型微指令
   : 基本格式：{ 微操作码（μOP） | 目的地址（Rd） | 源地址 }

   - 类似机器指令，采用微操作码编译法
   - 一条微指令定义并执行一种基本操作

   :+1: 微指令短、简单、规整，便于编写微程序  
   :-1: 微程序长，执行速度慢，效率低

3. 混合型微指令
   : 在垂直型的基础上增加不太复杂的并行操作

   微指令较短，便于编写，微程序不长，提高执行速度

- 水平型并行操作能力强、效率高、灵活性强；垂直型较差
- 水平型执行指令时间短；垂直型较长
- 水平型微指令字长，微程序短；垂直型微指令字短，微程序长
- 垂直型类似机器指令，较容易掌握；水平型较难

##### 微程序控制单元设计

1. 写出对应机器指令的微操作命令及节拍安排
2. 确定微指令格式，包括微指令的编码方式、后继微指令地址的形成方式、微指令字长等
3. 编写微指令码点

##### 动态微程序设计和毫微程序设计

- 动态微程序设计
  : 在微程序控制的计算机中，能根据用户的要求改变微程序

  需要可写的 CM。可采用 EPROM

- 毫微程序设计
  : 在微程序控制的计算机中，指令由 CM 中的微程序来解释执行，通过控制线对硬件直接控制

  毫微存储器：二级 CM，存放毫微程序，用于解释微程序。毫微指令直接控制硬件

#### 硬布线和微程序对比

- 硬布线控制器

  - 优点：速度取决于电路延迟，速度快
  - 缺点：设计完成后无法通过额外修改添加新功能

- 微程序控制器

  - 优点：规整、灵活、可维护
  - 缺点：每条指令都需要从 CM 中取出，影响速度

|          | 硬布线控制器 | 微程序控制器 |
| :------: | :----------: | :----------: |
| 工作原理 | 组合逻辑电路 |    微程序    |
| 执行速度 |      快      |      慢      |
|  规整性  | 烦琐、不规整 |    较规整    |
| 应用场合 |   RISC CPU   |   CISC CPU   |
| 易扩充性 |     困难     |  易扩充修改  |

### 异常和中断机制

#### 异常

- CPU 内部产生的意外事件，又称**内中断**
- 与正在执行的指令相关的同步事件

1. 故障（Fault）
   : 在引起故障的指令启动后、执行结束前被检测到的异常事件

   - 指令译码时出现非法操作码。无法异常处理
   - 除法时除数为 0。无法异常处理
   - 缺段/缺页。经处理后可继续执行

2. 自陷（Trap）
   : 预先安排的异常事件，又称**陷阱**或**陷入**。CPU 执行自陷后，根据不同陷阱类型进行相应处理

   - 自陷指令为转移指令时，返回到转移目标的指令继续执行
   - 程序调试中的断点设置和单步跟踪
   - 系统调用指令、条件自陷指令

3. 终止（Abort）
   : 执行指令时发生了使计算机无法继续执行的硬件故障，终止程序，调出中断服务程序重启系统

   - 控制器出错、存储器校验错等
   - 不由特定指令产生，随机发生

故障和自陷属于程序性异常（软件中断）  
终止和外中断属于硬件中断

:memo: 异常不能被屏蔽，一旦出现就应立即处理

#### 中断

- CPU 外部的设备发出的中断请求，通常用于信息输入输出，又称**外中断**
- 与正在执行的指令无关的异步事件
- I/O 中断：键盘输入、打印机缺纸
- 发生某种特殊事件：用户按 Esc、定时器计数时间到

1. 可屏蔽中断
   : 通过可屏蔽中断请求线 INTR 发出的中断请求。CPU 可在中断控制器中设置相应屏蔽字进行屏蔽。优先级最低，关中断时不会被响应
2. 不可屏蔽中断
   : 通过专门的不可屏蔽中断请求线 NMI 发出的中断请求。不可被屏蔽，CPU 得以快速处理。优先级最高

   通常是紧急硬件故障，如电源掉电

#### 异常和中断的区别

1. 异常由特定指令在执行过程中产生；中断不和指令关联，不阻止指令的完成
2. 异常检测由 CPU 自身完成；中断请求由中断请求线送至 CPU

#### 异常和中断的处理

1. 关中断

   设置中断允许（IF）触发器实现。1 表示开中断，0 表示关中断

2. 保存断点和程序状态

   将程序断点（返回地址）和 PSW 保存至栈或特定寄存器，处理后返回  
   异常处理后需要重新执行指令，断点为当前指令；中断的断点为下一条指令

3. 识别异常和中断，转到相应的处理程序

   异常大多采用软件识别，中断可采用软件识别或硬件识别

   - 软件识别（非向量中断）

     CPU 设置异常状态寄存器，记录异常原因  
     操作系统使用统一的异常/中断查询程序，按优先级查询异常状态寄存器，检测异常/中断类型  
     先查询到的先被处理，之后转到内核中相应的处理程序

   - 硬件识别（向量中断）

     中断向量：异常/中断处理程序的首地址，存放于中断向量表  
     异常/中断指定中断类型号，中断类型号和中断向量一一对应  
     识别中断源获得中断类型号，根据类型号得到中断向量，转到对应的处理程序

:memo: 中断处理过程是由软/硬件协同实现的

### 指令流水线

提高处理机的并行性

1. 时间上的并行技术：任务每个阶段在不同功能部件上执行。流水线技术
2. 空间上的并行技术：设置多个相同功能部件，并行工作。超标量处理机

#### 指令流水线的阶段

1. 取指（IF）
   : 从指令存储器或 Cache 中取指令
2. 译码/读寄存器（ID）
   : 操作控制器对指令译码，同时从寄存器中取操作数
3. 执行/计算地址（EX）
   : 执行运算操作，或计算地址
4. 访存（MEM）
   : 对存储器进行读写操作
5. 写回（WB）
   : 将指令执行结果写回寄存器

- 指令流水段个数以最复杂指令所用的功能段个数为准
- 流水段的长度以最复杂操作所花的时间为准
- 流水线不能缩短单条指令的执行时间；大幅提高整体效率

|       |  $T$  | $2T$  | $3T$  | $4T$  | $5T$  | $6T$  | $7T$  | $8T$  |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  IF   | $I_1$ | $I_2$ | $I_3$ | $I_4$ | $I_5$ | $I_6$ | $I_7$ | $I_8$ |
|  ID   |       | $I_1$ | $I_2$ | $I_3$ | $I_4$ | $I_5$ | $I_6$ | $I_7$ |
|  EX   |       |       | $I_1$ | $I_2$ | $I_3$ | $I_4$ | $I_5$ | $I_6$ |
|  MEM  |       |       |       | $I_1$ | $I_2$ | $I_3$ | $I_4$ | $I_5$ |
|  WB   |       |       |       |       | $I_1$ | $I_2$ | $I_3$ | $I_4$ |

#### 指令集特征

1. 指令长度尽量一致。简化取指令和指令译码操作
2. 指令格式尽量规整，尽量保证源寄存器位置相同。在指令未知时就可取寄存器操作数
3. 采用 Load/Store 指令，其他指令不访存。可将 Load/Store 的地址计算和运算指令规整在同一周期中，减少操作步骤
4. 数据和指令在存储器中对齐存放。减少访存次数，在一个流水段内取得数据

#### 流水线的实现

#### 流水线冒险与处理

流水线无法正确执行后续指令，引起流水线阻塞或停顿

:memo: Cache 缺失的处理过程也会引起流水线阻塞

##### 结构冒险（资源冲突）

多条指令在同一时刻争用同一资源

1. 前一指令访存时，后一条相关指令（及后续指令）暂停一个时钟周期
2. 单独设置数据存储器和指令存储器，取数和取指各自在不同的存储器中进行。L1 Cache 即采用分离方式

##### 数据冒险（数据冲突）

下一条指令会用到当前指令计算的结果

数据相关是**对流水线影响最严重的指令相关**

类型

1. 写后读（Read After Write, RAW）相关
   : 当前指令在寄存器写入数据后，下一条指令才能读。否则读到旧数据
2. 读后写（Write After Read, WAR）相关
   : 当前指令在寄存器读出数据后，下一条指令才能写。否则读到新数据
3. 写后写（Write After Write, WAW）相关
   : 当前指令在寄存器写入数据后，下一条指令才能写。否则数据不是最新

:memo: 读后读（Read After Read, RAR）不影响流水线

解决方法

1. 数据相关的指令（及后续指令）暂停一至几个时钟周期，直到数据相关问题消失。分为硬件阻塞（stall）和软件插入 NOP 指令
2. 设置相关专用通路，直接把当前指令的 ALU 计算结果作为下一条指令的输入。称为**数据旁路技术**
3. 编译器对数据相关的指令编译优化，调整指令顺序

##### 控制冒险（控制冲突）

遇到转移、调用或返回等改变指令执行顺序的情况，造成断流

1. 对转移指令进行分支预测，尽早生成转移目标地址。分为简单（静态）预测和动态预测。静态预测总是预测条件不满足；动态预测根据程序执行的历史情况进行调整，准确率较高
2. 预取转移成功和不成功两个控制流方向上的目标指令
3. 加快和提前形成条件码
4. 提高转移方向的猜准率

#### 流水线的性能指标

##### 流水线的吞吐率

吞吐率（TP）指在单位时间内流水线完成的任务数量，或输出结果的数量

$$ TP=\frac{n}{T_k} $$

- $n$：任务数
- $T_k$：处理完 $n$ 个任务所用的时间

理想情况下，一条 $k$ 段流水线能在 $k+n-1$ 个时钟周期完成 $n$ 个任务

$$ TP=\frac{n}{(k+n-1)\Delta t} $$

- $k$：流水段的段数
- $\Delta t$：时钟周期

连续任务数 $n\to\infty$ 时，得到最大吞吐率 $TP_\text{max}=\frac{1}{\Delta t}$

##### 流水线的加速比

加速比（S）指完成同样一批任务，不使用流水线和使用流水线所用的时间之比

$$ S=\frac{T_0}{T_k} $$

- $T_0$：不使用流水线的总时间
- $T_k$：使用流水线的总时间

$T_0=kn\Delta t$，$T_k=(k+n-1)\Delta t$，代入得

$$ S=\frac{kn}{k+n-1} $$

连续任务数 $n\to\infty$ 时，得到最大加速比 $S_\text{max}=k$

#### 高级流水线技术

1. 超标量流水线技术
   : 也称动态多发射技术。每个时钟周期并发多条独立指令，以并行操作方式将两条或多条指令编译并执行。需要多个功能部件

   - 不能调整指令的顺序
   - 通过编译优化，把可并行的指令搭配起来

2. 超长指令字技术
   : 也称静态多发射技术。通过编译程序，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字。需要采用多个处理部件
3. 超流水线技术
   : 增加流水线功能段划分，提高流水线吞吐率

   - 流水线级数越多，用于流水寄存器的开销越大

超流水线充满后 $\text{CPI}=1$，主频更高；多发射流水线充满后 $\text{CPI}<1$  
多发射流水线成本更高，控制更复杂

### 多处理器

#### SISD、SIMD、MIMD

1. 单指令流单数据流（SISD）结构
   : 处理器一段时间内执行一条指令，串行执行指令

   - 传统串行计算机结构，通常仅包含一个处理器和一个存储器
   - 有些采用流水线方式提高速度，设置多个功能部件，采用多模块交叉方式组织存储器

2. 单指令流多数据流（SIMD）结构
   : 一个指令流同时对多个数据流进行处理，称为数据级并行技术

   - 通常由一个指令控制部件、多个处理单元组成
   - 每个处理单元有独立的地址寄存器，因此处理的数据不同
   - 使用 for 循环处理数组时最有效
   - 向量处理器：SIMD 的变体，收集一组数据放入一组向量寄存器，流水化操作

3. 多指令流单数据流（MISD）结构
   : 同时执行多条指令，处理同一个数据

   :memo: **不存在这样的机器**

4. 多指令流多数据流（MIMD）结构
   : 同时执行多条指令，分别处理多个不同的数据。线程级（或以上）并行技术。分为多计算机系统和多处理器系统

   - 多计算机系统：每个计算机节点具有私有存储器，独立主存地址空间。又称消息传递 MIMD
   - 多处理器系统：共享存储多处理器（SMP）系统，具有共享的单一地址空间。又称共享存储 MIMD

#### 硬件多线程

硬件多线程的 CPU 中，每个线程有单独的通用寄存器组、PC 等，线程切换只需激活选中的寄存器

1. 细粒度多线程
   : 多个线程轮流交叉执行指令，线程之间的指令不相关，可以乱序并行

   - 能在每个时钟周期切换线程

2. 粗粒度多线程
   : 仅在一个线程出现较大开销的阻塞时（如 Cache 缺失）切换线程

   - 流水线阻塞时必须清除被阻塞的流水线，新线程指令执行前重载流水线
   - 线程切换开销比细粒度多线程更大

3. 同时多线程（SMT）
   : 两种技术的变体。在一个时钟周期中发射多个不同线程的多条指令。实现指令级并行、线程级并行

超线程（Hyper-threading）即 SMT，单核设置两套线程状态部件，共享 Cache 和功能部件

#### 多核处理器

- 将多个处理单元（核，core）集成在单个 CPU
- 核可有自己的 Cache，也可共享一个 Cache
- 核一般对称，且共享主存。共享存储的对称多处理器
- 每个核在同一时刻都有线程在执行，即物理上并行

#### 共享内存多处理器（SMP）

共享单一物理地址空间的多处理器  
处理器通过存储器中的共享变量互相通信  
仍可以在自己的虚拟地址空间中单独运行程序

1. 统一存储访问（UMA）多处理器
   : 每个处理器对所有存储单元的访问时间大致相同

   1. 基于总线连接
   2. 基于交叉开关网络连接
   3. 基于多级交换网络连接

   - 内存控制器不在 CPU，集成在北桥芯片中。CPU 通过前端总线和北桥芯片相连
   - 前端总线的争用使得前端总线成为瓶颈

2. 非统一存储访问（NUMA）多处理器
   : 取决于处理器及访问的字，某些访存请求比其他的快

   1. NC-NUMA：处理器中不带高速缓存
   2. CC-NUMA：处理器中带有一致性高速缓存

   - 内存控制器集成在 CPU 内部，每个 CPU 有独立的内存控制器
   - 每个 CPU 独立连接到一部分内存，称为本地内存
   - CPU 之间通过 QPI 总线相连，可经由此访问其他 CPU 的远程内存
   - 访问本地内存明显快于远程内存

需要进行同步，防止在其他处理器完成对共享变量的修改之前，就开始使用该变量  
通过对共享变量加锁来控制互斥访问

## 总线

一组能为多个部件分时共享的公共信息传送线路，具有**分时**和**共享**的特点

- 分时
  : 同一时刻只允许一个部件向总线发送信息，多个部件只能分时地发送
- 共享
  : 总线上可以挂接多个部件，各个部件可通过总线相互交换信息，多个部件可同时从总线上接收相同的信息

### 总线设备

- 主设备
  : 获得总线控制权的设备
- 从设备
  : 被主设备访问的设备，只能响应主设备发来的总线命令

### 总线特性

- 机械特性：尺寸、形状
- 电气特性：传输方向、有效电平范围
- 功能特性：每根传输线的功能
- 时间特性：信号和时序的关系

### 总线的分类

1. 片内总线
   : 芯片内部的总线，CPU 内寄存器之间、寄存器与 ALU 之间的公共连接线
2. 系统总线
   : 计算机系统内各功能部件之间连接的总线

   1. 数据总线：传输功能部件之间的数据信息

      - 双向传输
      - 位数与机器字长、存储字长有关

   2. 地址总线：指出数据总线上的源/目的数据所在的主存单元或 I/O 端口地址

      - 单向传输
      - 位数与主存地址空间大小有关

   3. 控制总线：传输控制信息，包括 CPU 送出的控制命令和主存（或外设）返回 CPU 的反馈信号

3. I/O 总线
   : 连接中低速的 I/O 设备，通过 I/O 接口与系统总线相连。将低速设备与高速总线分离，提升总线的系统性能

   常见的有 USB、PCI 总线

4. 通信总线
   : 在计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线。也称**外部总线**

- 按时序控制方式：同步总线、异步总线
- 按数据传输格式：并行总线、串行总线

### 系统总线的结构

内部总线结构见[数据通路](#数据通路的基本结构)

#### 单总线结构

CPU、主存、I/O 设备（通过 I/O 接口）挂在一组总线上

允许 I/O 设备之间、I/O 设备与主存之间直接交换信息  
CPU 与主存、CPU 与外设之间可直接交换信息

:+1: 结构简单，成本低，易于接入新的设备  
:-1: 带宽低，负载重，多个部件争用唯一的总线，不支持并发传送

:memo: 单总线不只有一根信号线，可细分为数据、地址、控制总线

#### 双总线结构

主存总线：CPU、主存、通道之间传送数据  
I/O 总线：多个外部设备和通道之间传送数据

:+1: 将低速 I/O 设备分离出来，存储器总线和 I/O 总线分离  
:-1: 需要增加通道等硬件设备

#### 三总线结构

主存总线：CPU 和主存之间传送数据  
I/O 总线：CPU 和各类外设之间通信  
直接内存访问（DMA）总线：主存和高速外设之间直接传送数据

:+1: 提高了 I/O 设备的性能，更快地响应命令，提高系统吞吐率  
:-1: 系统工作效率较低

### 常见总线标准

1. ISA
   : Industry Standard Architecture，工业标准体系结构

   最早出现的微型计算机的系统总线

2. EISA
   : Extended ISA，扩展的 ISA

   配合 32 位 CPU 设计的扩展总线，兼容 ISA

3. VESA
   : Video Electronics Standards Association，视频电子标准协会

   32 位局部总线，针对多媒体 PC 要求高速传送活动图像的大量数据

4. PCI
   : Peripheral Component Interconnect，外部设备互连

   高性能 32/64 位总线，为高度集成的外围部件、扩充插板和处理器/存储器系统设计  
   常用的有显卡、声卡、网卡  
   支持即插即用  
   与处理器时钟频率无关的高速外围总线，属于局部总线

5. AGP
   : Accelerated Graphics Port，加速图形接口

   视频接口标准，连接主存和图形存储器  
   传输视频和三维图形数据，属于局部总线

6. PCI-E
   : PCI-Express

   最新总线接口标准，将全面取代 PCI 和 AGP

7. RS-232C
   : 由美国电子工业协会（EIA）推荐的串行通信总线

   应用于串行二进制交换的数据终端设备（DTE）和数据通信设备（DCE）之间的标准接口

8. USB
   : Universal Serial Bus，通用串行总线

   I/O 总线，属于设备总线  
   可即插即用、热插拔，有很强的连接能力

9. PCMCIA
   : Personal Computer Memory Card International Association

   广泛应用于笔记本电脑，用于扩展功能的小型插槽  
   即插即用

10. IDE
    : Integrated Drive Electronics，集成设备电路

    即 ATA，一种 IDE 接口磁盘驱动器接口类型  
    硬盘、光驱

11. SCSI
    : Small Computer System Interface，小型计算机系统接口

    用于计算机和智能设备之间（硬盘、软驱）系统级接口的独立处理器标准

12. SATA
    : Serial Advanced Technology Attachment，串行高级技术附件

    基于行业标准的串行硬件驱动器接口

### 总线性能指标

1. 总线传输周期
   : 一次总线操作所需要的时间。包括申请阶段、寻址阶段、传输阶段、结束阶段。由若干总线时钟周期构成
2. 总线时钟周期
   : 机器的时钟周期
3. 总线工作频率
   : 操作频率，总线周期的倒数。1 秒内传送几次数据
4. 总线时钟频率
   : 机器的时钟频率
5. 总线宽度
   : 总线位宽。总线上能同时传输的数据位数，通常指总线的根数
6. 总线带宽
   : 总线的最大数据传输率，单位时间内总线上最多可传输数据的位数
7. 总线复用
   : 一种信号线在不同的时间传输不同的信息。可使用较少的线传输更多的信息
8. 信号线数
   : 地址、数据、控制 3 种总线数的总和

:memo: 总线最主要的性能指标为总线宽度、总线工作频率、总线带宽

### 总线事务

从请求总线到完成总线使用的操作序列

1. 请求阶段
   : 主设备（CPU 或 DMA）发出总线传输请求，获得总线控制权
2. 仲裁阶段
   : 总线仲裁机构决定将下一个传输周期的总线使用权授予某个申请者
3. 寻址阶段
   : 主设备通过总线给出要访问的从设备地址及有关命令，启动从模块
4. 传输阶段
   : 主模块和从模块进行数据交换，可单向或双向。一般只能传输一个字长的数据
5. 释放阶段
   : 主模块的有关信息从系统总线上撤除，让出总线使用权

突发（猝发）传送方式能进行连续成组数据的传送  
寻址阶段发送连续数据单元的首地址  
传输阶段传送多个连续单元的数据，每个时钟周期传送一个字长  
一组数据全部传送完毕之后再释放总线

### 总线定时

总线在双方交换数据的过程中需要时间上配合关系的控制

#### 同步定时方式

采用一个统一的时钟信号来协调发送和接收双方的传送定时关系  
时钟产生相等的时间间隔作为总线周期

:+1: 传送速度快，传输速率高，总线控制逻辑简单  
:-1: 属于强制性同步，不能及时进行数据通信的有效性检验，可靠性差

适用于总线长度较短，且总线所接部件的存取时间比较接近的系统

#### 异步定时方式

没有统一的时钟和固定的时间间隔，依靠传送双方的握手信号实现定时控制  
主设备提出请求，从设备发出回答

:+1: 总线周期长度可变，保证速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间配合  
:-1: 控制方式更复杂，速度较慢

1. 不互锁方式
   : 主设备发出请求后一段时间撤销；从设备发出回答后一段时间撤销
2. 半互锁方式
   : 主设备发出请求，收到回答后才撤销；从设备发出回答后一段时间撤销
3. 全互锁方式
   : 主设备发出请求，收到回答后才撤销；从设备发出回答，获知主设备撤销后才撤销

### 总线的优点

1. 简化系统结构，便于设计制造
2. 减少连线数目，便于布线，减小体积，提高系统可靠性
3. 便于接口设计
4. 便于系统扩充、更新、灵活配置，实现系统的模块化
5. 便于设备的软件设计
6. 便于故障诊断和维修，降低成本

## 输入/输出系统

### I/O 系统基本概念

### I/O 接口

#### I/O 接口的功能

1. 地址译码和设备选择
2. 主机和外设的通信联络控制：主机与外设时序配合
3. 实现数据缓冲：匹配 CPU 和外设的速度
4. 信号格式的转换：电平转换、并/串或串/并转换、模/数或数/模转换
5. 传送控制命令和状态信息：CPU 发出启动命令/响应中断请求，外设反馈状态信息/发出中断请求

#### I/O 接口的结构

- 主机侧（系统总线）：I/O 接口 - 内存、CPU

  - 数据总线

    - 数据缓冲寄存器 - 内存/CPU 寄存器
    - 状态寄存器 - CPU
    - CPU - 控制寄存器

  - 地址总线

    - 寄存器地址送至 I/O 控制逻辑部件

  - 控制总线

    - 读/写信号送至 I/O 控制逻辑部件
    - 传送仲裁信号和握手信号

- 设备侧（接口电缆）

  - 控制：I/O 控制逻辑对控制寄存器的命令字进行译码，控制信号 $\to$ 外设
  - 数据：数据缓冲寄存器 $\longleftrightarrow$ 外设
  - 状态：外设状态 $\to$ 状态寄存器

数据缓冲寄存器、状态/控制寄存器的访问通过 **I/O 指令**完成  
I/O 指令为特权指令，只能在操作系统内核的底层 I/O 软件中使用

:memo: 端口指接口电路中可以进行读/写的寄存器，若干端口加上相应的控制逻辑组成接口

#### I/O 接口类型

- 按数据传送方式

  1. 并行接口：一字节或一个字的所有位同时传送
  2. 串行接口：按位逐个传送

- 按主机访问 I/O 设备的控制方式

  1. 程序查询接口
  2. 中断接口
  3. DMA 接口

- 按功能选择的灵活性

  1. 可编程接口
  2. 不可编程接口

#### I/O 端口及编址

I/O 端口指接口电路中可被 CPU 直接访问的寄存器，包括数据端口、状态端口、控制端口  
CPU 能对数据端口读写，状态端口读，控制端口写

端口编址方式

1. 统一编址（存储器映射方式）
   : 把 I/O 端口当作存储器的单元进行地址分配，通常为地址空间的顶端

   CPU 不需要设置专门的 I/O 指令，用统一的访存指令就能访问 I/O 端口

   :+1: 不需要专门的 I/O 指令，CPU 访问 I/O 更灵活、方便，有较大的编址空间  
   :-1: 端口占用存储器地址，内存容量变小，执行速度较慢

2. 独立编址（I/O 映射方式）
   : 每个端口分配一个 I/O 端口号，I/O 端口的地址空间与主存地址空间独立

   地址无法从地址码的形式上区分，需要设置专门的 I/O 指令

   :+1: I/O 指令与存储器指令区分，程序清晰，便于理解  
   :-1: I/O 指令少，只能对端口进行传送操作，控制更复杂

### I/O 方式

#### 程序查询方式

接口中设置数据缓冲寄存器和设备状态寄存器

1. CPU 初始化，预置传送参数
2. 向 I/O 接口发出命令字，启动 I/O 设备
3. 从外设接口读取状态信息
4. CPU 不断查询 I/O 设备状态，直到外设就绪
5. 传送数据
6. 修改地址和计数器参数
7. 判断传送是否结束，若未结束转 3

CPU 启动 I/O后就必须停止现行程序  
CPU 踏步等待，与 I/O 串行工作

:+1: 接口设计简单，设备量少，易于实现  
:-1: CPU 在传送过程中要花费很多时间查询和等待，一段时间内只能和一台外设交换信息，效率低

#### 程序中断方式

1. CPU 启动外设，继续执行当前的程序
2. 外设完成数据传送的准备工作，向 CPU 发出中断请求
3. 若可以响应中断，CPU 暂停正在执行的程序，执行中断服务程序，为外设服务
4. 完成一次数据传送后，CPU 返回原来的程序

中断系统对每个中断源设置中断请求标记触发器，1 表示中断源有请求。触发器组成中断请求标记寄存器，可集中于 CPU 或分散在各个中断源

:+1: 比程序查询方式有效  
:-1: 每个字的传输都需要经过 CPU，仍会消耗较多 CPU 时间

##### 中断响应优先级

中断响应判优通过硬件排队器实现

1. 不可屏蔽中断 $>$ 内部异常 $>$ 可屏蔽中断
2. 内部异常中，硬件故障 $>$ 软件中断
3. DMA 中断请求 $>$ I/O 设备传送中断请求
4. I/O 传送中，高速设备 $>$ 低速设备，输入设备 $>$ 输出设备，实时设备 $>$ 普通设备

:memo: 中断优先级包括**响应优先级**和**处理优先级**，响应优先级固定不变，处理优先级可通过中断屏蔽动态调整

##### CPU 响应中断的条件

1. 中断源有中断请求
2. CPU 允许中断且开中断（仅针对可屏蔽中断）
3. 一条指令执行完毕（异常不受此限制），没有更紧迫的任务

:memo: CPU 在每条指令执行阶段的结束时刻查询 I/O 中断

##### 中断响应过程

经由**中断隐指令**转去执行中断服务程序。中断隐指令是硬件实现的一系列自动操作

见[异常和中断的处理](#异常和中断的处理)

##### 中断处理过程

1. 关中断
2. 保存断点
3. 中断服务程序寻址
4. 保存现场和屏蔽字：现场信息存入栈中，由软件实现；断点信息由 CPU 自动保存至栈或指定寄存器，由硬件实现
5. 开中断：允许响应更高级中断请求，中断嵌套
6. 执行中断服务程序
7. 关中断
8. 恢复现场和屏蔽字：由中断服务程序完成
9. 开中断、中断返回：中断返回指令使其返回到原程序的断点处

1-3 由中断隐指令完成，4-9 由中断服务程序完成

##### 多重中断和中断屏蔽技术

单重中断
: 执行中断服务程序时，对新的更高优先级中断请求不予响应

多重中断（中断嵌套）
: 转去执行新的中断请求

需要满足的条件：

1. 中断服务程序中提前设置开中断
2. 优先级高的中断源有权中断优先级低的中断源

中断处理优先级可利用中断屏蔽技术动态调整，否则与响应优先级相同

中断源有屏蔽触发器，1 表示屏蔽该中断源的请求，0 表示可申请  
所有屏蔽触发器构成屏蔽字寄存器，内容称为屏蔽字

#### DMA 方式

主存和 DMA 接口之间有一条直接数据通路，不经过 CPU  
DMA 控制器有控制系统总线的能力

特点：

- 主存可被 CPU 访问，也可被外设访问
- 传送数据块时，主存地址、传送计数由硬件电路直接实现
- 主存中开辟专用缓冲区
- 传送速度快，CPU 和外设并行工作
- 传送开始前进行预处理，结束后通过中断进行后处理

DMA 控制器（DMA 接口）的组成：

1. 主存地址计数器：存放目标主存地址
2. 传送长度计数器：记录传送数据的长度，计数溢出时即传送完毕，发送中断请求
3. 数据缓冲寄存器：暂存传送的数据
4. DMA 请求触发器：I/O 设备准备好数据后给出控制信号，DMA 请求触发器置位
5. 控制/状态逻辑：控制和时序电路及状态标志组成，制定传送方向，修改传送参数，协调同步 DMA 请求信号和 CPU 响应信号
6. 中断机构：一个数据块传送完毕后触发，提出中断请求

##### DMA 的传送方式

1. 停止 CPU 访存

   DMA 控制器向 CPU 发送停止信号，CPU 脱离总线停止访存。DMA 传送一块数据结束后，通知 CPU 并交还总线控制权

2. 周期挪用（周期窃取）

   1. CPU 未访存，无冲突
   2. CPU 正在访存，待存取周期结束后让出总线控制权
   3. I/O 和 CPU 同时请求访存，CPU 放弃占用总线

   I/O 访存优先级高于 CPU，挪用一个或几个存取周期，传送完一个数据即释放总线（**单字传送**）

3. DMA 和 CPU 交替访存

   适用于 CPU 工作周期比主存存取周期长的情况  
   一个 CPU 周期分为两部分，分别供 DMA 和 CPU 访存  
   总线使用权通过分时控制，不需要申请、建立、归还

##### DMA 的传送过程

1. 预处理

   1. CPU 执行 I/O 指令测试 I/O 设备状态
   2. 设置 DMA 控制器的寄存器初值、设置传送方向，启动设备
   3. I/O 设备准备好数据，向 DMA 控制器发送 DMA 请求
   4. DMA 控制器向 CPU 发送总线请求

2. 数据传送

   数据传送以单字节、单字或数据块为单位  
   数据块传送通过循环实现，循环由 DMA 控制器实现

   :memo: 数据传送阶段完全由 DMA（硬件）控制

3. 后处理

   DMA 控制器向 CPU 发送中断请求  
   CPU 执行中断服务程序，包括校验数据、测试传送是否出错、决定是否继续传送

##### DMA 和中断方式的区别

1. 中断方式需要保护和恢复现场；DMA 除了预处理和后处理外不占用 CPU 资源
2. 中断请求的响应发生在指令的执行周期后；DMA 请求的响应可发生在每个机器周期结束时，CPU 不占用总线即可
3. 中断传送需要 CPU 干预；DMA 传送无需 CPU 干预，传输效率高
4. DMA 请求的优先级高于中断请求
5. 中断可处理异常事件；DMA 仅局限于 I/O 操作
6. 中断靠程序传送；DMA 靠硬件传送
