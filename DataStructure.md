# DATA STRUCTURE

[toc]

## 绪论

### 数据结构三要素

1. 逻辑结构
   : 数据元素间的逻辑关系
2. 存储结构（物理结构）
   : 数据结构在计算机中的表示

   - 顺序存储
   - 链式存储
   - 索引存储
   - 散列存储（哈希存储）

3. 运算
   : 运算的定义（针对逻辑结构）和实现（针对物理结构）

### 算法的特性

1. 有穷性
2. 确定性
3. 可行性
4. 输入（$\geq0$）
5. 输出（$\geq1$）

### 算法的目标

1. 正确性
2. 可读性
3. 健壮性
4. 效率与低存储量需求

## 线性表

### 顺序表

插入、删除需要移动元素，时间复杂度 $O(n)$  
支持随机存取，时间复杂度 $O(1)$  
按值查找时间复杂度 $O(n)$

### 链表

链表中均包含**头结点**，使得第一个位置上的操作与其他位置一致，空表与非空表的处理统一

1. 单链表

   按序号查找、按值查找均需要从头结点开始遍历，时间复杂度 $O(n)$  
   插入、删除需要查找前驱结点，时间复杂度 $O(n)$

2. 双链表

   按序号查找、按值查找与单链表相同  
   插入、删除需要同时更改 `prior` 和 `next`

3. 循环单链表

   尾结点的 `next` 指向头结点  
   可仅设尾指针指向尾结点，此时对表头和表尾的操作均只需 $O(1)$ 的复杂度  
   使用 `head->next == head` 判空

4. 循环双链表

   尾结点的 `next` 指向头结点，头结点的 `prior` 指向尾结点

5. 静态链表

   使用连续的内存空间存储  
   结点的 `next` 域表示下一个元素的**数组下标**（与元素的位序区别）  
   `next == -1` 表示尾结点

### 顺序表与链表对比

1. 顺序表可随机存取，链表需从表头开始依次访问
2. 顺序表中逻辑相邻的元素，物理位置也相邻
3. 链表需要额外存储指针域，存储密度较小
4. 顺序表存储空间无法扩充，链表可在需要时申请分配，更加灵活

## 栈

只允许在一端插入或删除的线性表  
后进先出（LIFO）  
Catalan 数：$n$ 个不同元素进栈，出栈元素不同排列个数为

$$ h_n=\frac{1}{n+1}{2n\choose n} $$

> $h_0=h_1=1$  
> 固定第一个数在第 $i$ 位出栈，其排列个数为 $h_{i-1}h_{n-i}$  
> 可得递推公式
>
> $$ h_n=\sum_{i=1}^nh_{i-1}h_{n-i} $$
>
> 数学归纳法

### 顺序栈

共享栈：两个栈共享一个数组空间，栈底分别位于两端，栈顶向中间延伸  
当栈顶相邻时，共享栈为满

### 链栈

链栈**不包含头结点**，`head` 指向栈顶

### 栈的应用

1. 括号匹配
2. 表达式求值：将中缀表达式转换为后缀表达式，再对后缀表达式求值
3. 递归工作栈

## 队列

只允许一端插入，另一端删除的线性表  
先进先出（FIFO）

### 顺序队列（循环队列）

使用循环结构解决假上溢问题  
循环队列使用顺序表表示

### 链队列

链队列包含**头结点**，否则在创建第一个结点或删除最后一个结点时操作不统一

链式表示适合元素变动比较大的情形，且不存在溢出的问题。当要同时使用多个队列/栈时，最好使用链式

### 双端队列

两端都允许入队和出队  
输出/输入受限的双端队列：允许一端插入删除，另一端只能插入/删除的双端队列

### 队列的应用

1. 二叉树层次遍历
2. 主机与外部设备速度不匹配，多用户资源竞争

## 特殊矩阵的压缩存储

### 对称矩阵

将下三角部分（包含主对角）的元素存储在一维数组中  
$n$ 阶矩阵需要长度为 $\frac{n(n+1)}{2}$ 的数组  
$a_{ij}$ 的值在数组中的下标可表示为

$$
k=
\begin{cases}
    \frac{i(i-1)}{2}+j-1&i\geq j\\
    \frac{j(j-1)}{2}+i-1&i<j
\end{cases}
$$

### 三角矩阵

存储下三角/上三角（包含主对角），使用一个空间存储常量  
$n$ 阶矩阵需要长度为 $\frac{n(n+1)}{2}+1$ 的数组  
下三角矩阵中 $a_{ij}$ 的值在数组中的下标可表示为

$$
k=
\begin{cases}
    \frac{i(i-1)}{2}+j-1&i\geq j\\
    \frac{n(n+1)}{2}&i<j
\end{cases}
$$

上三角矩阵中 $a_{ij}$ 的值在数组中的下标可表示为

$$
k=
\begin{cases}
    \frac{(2n-i+2)(i-1)}{2}+j-i&i\leq j\\
    \frac{n(n+1)}{2}&i>j
\end{cases}
$$

### 三对角矩阵

将三条对角线上的元素按行优先方式存储在一维数组中  
$n$ 阶矩阵需要长度为 $3n-2$ 的数组  
$a_{ij}$ 的值在数组中的下标可表示为

$$ k=2i+j-3 $$

### 稀疏矩阵

仅存储非零元素，以（行，列，值）的三元组形式存储  
采用数组或十字链表

## 串

### 简单模式匹配

### KMP 算法

[代码实现](./Algorithm/StringPatternMatching.cpp)

当下一个位置上的字符和当前字符相同时必定导致失配，因此递归取下一个位置直到字符不同，得到改进后的 next 数组

主串的长度为 $n$，模式串的长度为 $m$，BF 算法的时间复杂度为 $O(mn)$，KMP 算法的时间复杂度为 $O(m+n)$

## 树

### 树的性质

1. $n$ 个结点的树有 $n-1$ 条边
2. 结点数等于所有结点度数和加 $1$
3. 度为 $m$ 的树中第 $i$ 层至多有 $m^{i-1}$ 个结点
4. 高度为 $h$ 的 $m$ 叉树至多有 $\frac{m^h-1}{m-1}$ 个结点
5. 具有 $n$ 个结点的 $m$ 叉树的最小高度为 $\lceil\log_m((m-1)n+1)\rceil$

### 特殊二叉树

二叉树可以为空

#### 满二叉树

高度为 $h$，含有 $2^h-1$ 个结点  
对满二叉树编号，从上至下从左至右，根结点为 $1$  
对于结点 $i$，其父结点为 $\lfloor\frac{i}{2}\rfloor$，左孩子为 $2i$，右孩子为 $2i+1$

#### 完全二叉树

高度为 $h$，含有 $n$ 个结点，对应满二叉树中前 $n$ 个结点

1. 若 $i\leq\lfloor\frac{n}{2}\rfloor$，则结点 $i$ 为分支结点，否则为叶结点。即最后一个分支结点为 $n$ 的父结点
2. 叶结点只在最大两层中，最大层的叶结点均在左侧位置
3. 若有度为 $1$ 的结点，只可能有一个（即最后一个分支结点），且只有左孩子
4. 若结点 $i$ 为叶结点或只有左孩子，则大于 $i$ 的均为叶结点
5. 若 $n$ 为奇数，所有分支结点均有左孩子和右孩子；若 $n$ 为偶数，最后一个分支结点只有左孩子

#### 二叉排序树

见[二叉排序树](#二叉排序树binary-search-tree-bst)

#### 平衡二叉树

见[平衡二叉树](#平衡二叉树balanced-binary-tree-avl)

### 二叉树的性质

1. 非空二叉树上的叶结点数等于度为 $2$ 的结点数加 $1$，即 $n_0=n_2+1$
2. 非空二叉树第 $k$ 层最多有 $2^{k-1}$ 个结点
3. 高度为 $h$ 的二叉树最多有 $2^h-1$ 个结点
4. 在完全二叉树中，对于结点 $i$

   1. 父结点为 $\lfloor\frac{i}{2}\rfloor$。即 $i$ 为偶数，父结点为 $\frac{i}{2}$，$i$ 为左孩子；$i$ 为奇数，父结点为 $\frac{i-1}{2}$，$i$ 为右孩子
   2. 左孩子为 $2i$（$2i\leq n$），右孩子为 $2i+1$（$2i+1\leq n$）
   3. 位于第 $\lfloor\log_2i\rfloor+1$ 层

5. 有 $n$ 个结点的完全二叉树的高度为 $\lceil\log_2(n+1)\rceil$ 或 $\lfloor\log_2n\rfloor+1$

### 二叉树存储结构

#### 顺序存储

对于高度为 $h$ 的二叉树，使用 $2^h-1$ 个空间，按编号顺序存储，不存在的结点使用 $0$ 表示  
对于满二叉树和完全二叉树比较合适

#### 链式存储

包含数据域、左指针域、右指针域（二叉链表）  
还可增加指向父结点的指针，形成三叉链表  
含有 $n$ 个结点的二叉链表包含 $n+1$ 个空指针域

### 二叉树遍历

- 先序遍历
- 中序遍历
- 后序遍历
- 层次遍历：借助队列

唯一确定一棵二叉树

- 先序 + 中序
- 后序 + 中序
- 层次 + 中序

先序 + 后序无法唯一确定

### 线索二叉树

二叉树中的空指针域指向其遍历序列中的前驱/后继，需添加两个标志域标识指针域的作用  
可以在线索链表上添加头结点，`lchild` 指向 `root`，`rchild` 指向最后一个结点；第一个结点的 `lchild` 和最后一个结点的 `rchild` 指向头结点  
在后序线索二叉树中遍历寻找后继时需要知道当前结点的父结点，即使用带标志域的三叉链表

### 树的存储结构

#### 双亲表示法

使用连续空间存储结点，结点中设置伪指针，存储父结点的数组下标  
根结点数组下标为 $0$，伪指针域为 $-1$

利用每个结点只有一个父结点的特性

可直接获取父结点，获取孩子需要遍历整个结构

#### 孩子表示法

每个结点包含子链表域，指向所有孩子连接形成的单链表

可直接获取孩子，获取父结点需要遍历所有结点的子链表

#### 孩子兄弟表示法（二叉树表示法）

使用二叉链表，结点包含数据、第一个孩子的指针、下一个兄弟结点的指针

方便将树转换为二叉树，缺点是不易查找父结点（可增加父结点指针域）

### 树和森林转换为二叉树

树和森林均可一一对应地转换为二叉树

#### 树 $\to$ 二叉树

结点左指针指向第一个孩子，右指针指向下一个兄弟结点（同孩子兄弟表示法）  
由此得到的二叉树**没有右子树**

#### 森林 $\to$ 二叉树

将森林中每棵树转换为二叉树，它们的根结点视作兄弟相连

### 树的遍历

- 先根遍历：与对应二叉树的先序遍历相同
- 后根遍历：与对应二叉树的中序遍历相同
- 层次遍历

### 森林的遍历

递归方法定义森林的遍历

- 先序遍历：与对应二叉树的先序遍历相同

  1. 访问第一棵树的根结点
  2. 先序遍历第一棵树的根结点的子森林
  3. 先序遍历其余的树构成的森林

- 中序遍历：与对应二叉树的中序遍历相同

  1. 中序遍历第一棵树的根结点的子森林
  2. 访问第一棵树的根结点
  3. 中序遍历其余的树构成的森林

|  树   | 森林  | 二叉树 |
| :---: | :---: | :----: |
| 先根  | 先序  |  先序  |
| 后根  | 中序  |  中序  |

### 树的应用

#### 哈夫曼树

带权路径长度（WPL）最小的二叉树为哈夫曼树（最优二叉树）

1. 初始结点均成为哈夫曼树的叶结点，权值越小到根结点的路径越长
2. $n$ 个初始结点，新建了 $n-1$ 个结点，哈夫曼树共包含 $2n-1$ 个结点
3. 新建的结点度为 $2$，带权结点度为 $0$，不存在度为 $1$ 的结点

- 固定长度编码：每个字符用等长二进制位表示
- 可变长度编码：每个字符用不等长二进制位表示

利用哈夫曼树可设计出总长度最短的二进制前缀编码

#### 并查集

使用树的[双亲表示法](#双亲表示法)作为并查集的存储结构，每个子集用一棵树表示，包含三种基本操作

1. `Initial`：将所有元素初始化为单元素集合
2. `Union`：合并两个不相交的集合
3. `Find`：找到某一元素所在的集合，返回其根结点

## 图

图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,E)$  
图不能为空，包含至少一个顶点

- 有向图
  : $E$ 为有向边（弧）
- 无向图
  : $E$ 为无向边（边）
- 简单图
  : 无重边，无顶点到自身的边
- 多重图
  : 存在重边或顶点到自身的边
- 完全图（简单完全图）
  : 任意两个顶点之间存在边
- 子图
  : $G'=(V',E')\quad G=(V,E)\quad V'\subseteq V\quad E'\subseteq E$
- 生成子图
  : $V(G')=V(G)$
- 连通
  : 无向图中，顶点 $v$ 到 $w$ 有路径存在
- 连通图
  : 无向图 $G$ 中任意两个顶点连通
- 连通分量
  : 无向图中的极大连通子图
- 强连通
  : 有向图中，顶点 $v$ 和 $w$ 双向都有路径存在
- 强连通图
  : 有向图 $G$ 中任意两个顶点强连通
- 强连通分量
  : 有向图中的极大强连通子图
- 生成树
  : 包含所有顶点的极小连通子图，去掉一边非连通，加上一边形成回路
- 生成森林
  : 非连通图中连通分量的生成树构成
- 度
  : 无向图中依附于顶点 $v$ 的边条数，记为 $\text{TD}(v)$。$\sum_{v\in V}\text{TD}(v)=2|E|$
- 入度
  : 有向图中以顶点 $v$ 为终点的边条数，记为 $\text{ID}(v)$
- 出度
  : 有向图中以顶点 $v$ 为起点的边条数，记为 $\text{OD}(v)$。$\text{TD}(v)=\text{ID}(v)+\text{OD}(v)$。$\sum_{v\in V}\text{ID}(v)=\sum_{v\in V}\text{OD}(v)=|E|$
- 带权图（网）
  : 边具有权值
- 稠密图
  : 边数很多
- 稀疏图
  : 边数很少。一般满足 $|E|<|V|\log|V|$ 可视为稀疏图
- 路径
  : 路径上边的数目为路径长度，起点与终点相同称为回路。若 $n$ 个顶点的图有大于 $n-1$ 条边，则一定存在回路
- 简单路径
  : 顶点不重复的路径。除起点和终点外顶点不重复的回路为简单回路
- 距离
  : 顶点 $u$ 到 $v$ 的最短路径长度。若路径不存在则记距离为 $\infty$
- 有向树
  : 一个顶点入度为 $0$，其余顶点入度为 $1$ 的有向图

### 图的存储

#### 邻接矩阵法

使用一个一维数组存储顶点信息，一个二维数组存储边的信息

无向图或有向图中以 $1$ 代表边存在，$0$ 代表边不存在

$$
A_{ij}=
\begin{cases}
    1&(v_i,v_j)|\langle v_i,v_j\rangle\in E\\
    0&(v_i,v_j)|\langle v_i,v_j\rangle\notin E
\end{cases}
$$

在带权图中，邻接矩阵存储边的权值

$$
A_{ij}=
\begin{cases}
    w_{ij}&(v_i,v_j)|\langle v_i,v_j\rangle\in E\\
    \infty&(v_i,v_j)|\langle v_i,v_j\rangle\notin E
\end{cases}
$$

1. 可直接使用二维数组作为邻接矩阵，省略顶点信息
2. 空间复杂度 $O(V^2)$
3. 适合稠密图的存储
4. 无向图的邻接矩阵是对阵矩阵，可采用压缩存储
5. 无向图中第 $i$ 行（列）的非零（或非 $\infty$）元素个数为顶点 $i$ 的度 $\text{TD}(v_i)$
6. 有向图中第 $i$ 行的非零（或非 $\infty$）元素个数为顶点 $i$ 的出度 $\text{OD}(v_i)$；第 $i$ 列的非零（或非 $\infty$）元素个数为顶点 $i$ 的入度 $\text{ID}(v_i)$
7. 容易判断任意两点间是否有边相连，难以计算总边数
8. $A^n$ 的元素 $A_{ij}^n$ 为顶点 $i$ 到顶点 $j$ 的长度为 $n$ 的路径数目

#### 邻接表法

对图中每一个顶点建立单链表，无向图中表示依附于该顶点的边，有向图中表示以该顶点为起点的弧  
顶点结点顺序存储，边结点链式存储

1. 无向图空间复杂度 $O(V+2E)$，有向图空间复杂度 $O(V+E)$
2. 适合稀疏图的存储
3. 容易找到任一顶点的所有邻边，难以确定任意两顶点间是否存在边
4. 在有向图中求顶点的出度只需计算邻接表的结点个数，求入度需要遍历所有邻接表。可采用逆邻接表求入度
5. 邻接表中结点次序不唯一

#### 十字链表

针对**有向图**的链式存储结构  
顶点结点顺序存储

1. 弧头相同的弧在同一个链表上，弧尾相同的弧在同一个链表上
2. 容易找到任一顶点为尾的弧，也易找到任一顶点为头的弧
3. 容易求出顶点的出度和入度
4. 十字链表表示不唯一，但十字链表唯一确定一个图

#### 邻接多重表

针对**无向图**的链式存储结构  
顶点结点顺序存储

1. 依附于同一个顶点的边在同一个链表上
2. 每个边结点同时链接在两个链表中
3. 同一条边在邻接表中存在两个结点，而在邻接多重表中只有一个结点

### 图的遍历

遍历过程中记下所有已访问过的顶点，以避免重复访问。可设置辅助数组 `visited[]` 用于标记  
遍历算法可用于判断图的连通性

- 若无向图连通，从任一顶点出发一次遍历可访问所有顶点，反之只能访问当前连通分量
- 若有向图中初始点到其他所有顶点都有路径，一次遍历可访问所有顶点。非强连通分量可能无法一次遍历访问所有顶点

#### 广度优先搜索（Breadth-First Search, BFS）

类似二叉树的层序遍历  
无需递归，需要借助辅助队列  
因需要借助辅助队列，最坏情况下空间复杂度为 $O(V)$  
采用邻接矩阵，时间复杂度为 $O(V^2)$；采用邻接表，时间复杂度为 $O(V+E)$

1. 单源最短路径问题：广度优先搜索总是按距离由近到远来遍历，可以用于求解某一顶点到其他顶点的距离（仅适用于边权值相等时）
2. 广度优先生成树：广度优先遍历过程中得到的遍历树。邻接矩阵表示唯一，得到的生成树唯一；邻接表得到的则不唯一

#### 深度优先搜索（Depth-First Search, DFS）

类似二叉树的先序遍历  
递归算法，需要借助递归工作站  
空间复杂度为 $O(V)$  
采用邻接矩阵，时间复杂度为 $O(V^2)$；采用邻接表，时间复杂度为 $O(V+E)$

1. 深度优先生成树：深度优先遍历过程中得到的遍历树，非连通图得到深度优先生成森林。基于邻接表得到的生成树不唯一
2. 对于一个图，基于邻接矩阵得到的 BFS 序列和 DFS 序列唯一，基于邻接表得到的不唯一

### 图的应用

#### 最小生成树（Minimum Spanning Tree, MST）

连通图的生成树包含所有顶点，包含尽可能少的边，去掉一边非连通，加上一边形成回路  
在带权连通无向图中，边权值之和最小的生成树称为最小生成树

1. 最小生成树不唯一。若 $G$ 是一棵树，其最小生成树为它本身
2. 最小生成树的边权值之和是唯一且最小的
3. 最小生成树的边数为顶点数减 $1$
4. 必定存在一棵包含了最小权值边的最小生成树

最小生成树通用算法：每次加入一条最小权值边且不形成回路

##### Prim 算法

设连通图 $G=(V,E)$，最小生成树 $T=(U,E_T)$

初始 $U=E_T=\varnothing$

1. 任选顶点 $u_0\in V$ 加入 $U$
2. 选取 $u\in V\setminus U$，使得 $u$ 与 $U$ 的距离最近，$u$ 加入 $U$，对应的边加入 $E_T$
3. 重复第二步，直到 $U=V$

- 时间复杂度 $O(V^2)$，不依赖于 $E$，适合应用于边稠密的图

##### Kruskal 算法

设连通图 $G=(V,E)$，最小生成树 $T=(U,E_T)$

初始 $U=V$，$E_T=\varnothing$

1. 选取 $e\in E\setminus E_T$，使得 $e$ 连接 $T$ 中不同的连通分量且权重最小，$e$ 加入 $E_T$
2. 重复第一步，直到 $T$ 连通

- 通常采用堆来存放边的集合，每次选择最小权值边需要 $O(\log E)$。每次添加新的边类似求解等价类，可以采用并查集描述 $T$
- 总的时间复杂度 $O(E\log E)$，适合应用于边稀疏的图

#### 最短路径

两点间的最短路径也包含了路径上其他顶点间的最短路径

##### Dijkstra 算法

求解单源最短路径问题

设带权图 $G=(V,E)$，邻接矩阵 `mat[,]`，源点为 $v_0$，已求得最短路径的顶点集 $S$  
辅助数组 `dist[]`：记录源点到各点最短路径的长度  
辅助数组 `path[]`：记录源点到各点最短路径的前驱点

初始 $S=\{v_0\}$，`dist[i] = mat[0, i]`，`path[i] = 0`

1. 选取 $v_j\in V\setminus S$，使得 `dist[j]` 最小，$v_j$ 加入 $S$
2. 更新 `dist[]`：$\forall v_k\in V\setminus S$，若 `dist[j] + mat[j, k] < dist[k]`，则 `dist[k] = dist[j] + mat[j, k]`，`path[k] = j`
3. 重复前两步，直到 $S=V$

- 时间复杂度 $O(V^2)$
- **边上带有负权值时不适用**，可能出现已加入 $S$ 的点通过负权值的边得到的路径比已求得的路径更短，此时无法更新
- 轮流将每个顶点作为源点应用一次 Dijkstra 算法，可求解任意两点间的最短路径长度，时间复杂度 $O(V^3)$

##### Floyd 算法

求解任意两点间的最短路径和路径长度

设带权图 $G=(V,E)$，邻接矩阵 `mat[,]`  
$n$ 阶方阵序列 $A^{(-1)},A^{(0)},A^{(1)},\cdots,A^{(n-1)}$，记录迭代过程中任意两点间的最短路径长度

初始 $A_{ij}^{(-1)}=$ `mat[i, j]`

1. 将 $v_k$ 作为中间顶点，对于所有顶点对 $(i,j)$，若 $A_{ik}^{(k-1)}+A_{kj}^{(k-1)}<A_{ij}^{(k-1)}$，则 $A_{ij}^{(k)}=A_{ik}^{(k-1)}+A_{kj}^{(k-1)}$，得到方阵 $A^{(k)}$
2. 对 $0\leq k\leq n-1$ 应用上述步骤，$n$ 次迭代后得到 $A^{(n-1)}$，即为任意两点间最短路径长度

- 时间复杂度 $O(V^3)$
- 允许图中含有带负权值的边，不允许包含负权值的边组成的回路

#### 有向无环图（Directed Acyclic Graph, DAG）

有向图中不存在环，称为有向无环图

- 描述表达式
- AOV 网
- AOE 网

#### 拓扑排序

使用 DAG 表示工程，顶点表示活动，有向边表示活动的先后关系，称为**顶点表示活动的网络**（Activity On Vertex Network, AOV）

由 DAG 的顶点组成的序列若满足以下条件，称为该图的一个拓扑排序：

1. 每个顶点出现且只出现一次
2. 若序列中 $A$ 在 $B$ 的前面，则不存在 $B$ 到 $A$ 的路径（若存在一条 $A$ 到 $B$ 的路径，则序列中 $B$ 在 $A$ 的后面）

- 每个 AOV 网都有一个或多个拓扑排序序列
- 入度为零的顶点，表示工程可以从该点开始或继续
- 若一个顶点有多个直接后继，则拓扑排序结果通常不唯一；若每个顶点有唯一的前驱后继关系，拓扑排序结果唯一
- 按拓扑排序的结果对顶点重新编号，得到的邻接矩阵可以是三角矩阵。对一般的有向图，若邻接矩阵为三角矩阵，则存在拓扑排序序列；反之不一定

##### 常用拓扑排序算法

1. 从 AOV 网中选取一个没有前驱的顶点并输出
2. 将该顶点和以它为起点的有向边从图中删除
3. 重复上述步骤，直到 AOV 网为空。若图非空且不存在无前驱的顶点，则说明图中必包含环

- 需要借助栈，利用 DFS 也可实现
- 输出顶点的同时还要删除以它为起点的边，采用邻接矩阵，时间复杂度 $O(V^2)$；采用邻接表，时间复杂度 $O(V+E)$

##### 逆拓扑排序

1. 从 AOV 网中选取一个没有后继的顶点并输出
2. 将该顶点和以它为终点的有向边从图中删除
3. 重复上述步骤，直到 AOV 网为空

#### 关键路径

在 DAG 中以顶点表示事件，有向边表示活动，权值表示活动的开销，称为**边表示活动的网络**（Activity On Edge, AOE）

开始顶点（源点）
: AOE 网中仅有一个入度为 $0$ 的顶点

结束顶点（汇点）
: 仅有一个出度为 $0$ 的顶点

关键路径
: 从源点到汇点的所有路径中，最长的路径

关键活动
: 关键路径上面的活动

- 事件 $v_k$ 的最早发生时间 $ve(k)$：事件能够发生的最早时间，从前往后递推。$ve(\text{source})=0$
- 事件 $v_k$ 的最迟发生时间 $vl(k)$：不推迟整个工程的前提下事件必须发生的最迟时间，从后往前递推。$vl(\text{sink})=ve(\text{sink})$
- 活动 $a_i$ 的最早开始时间 $e(i)$：活动能够开始的最早时间。若 $a_i=\langle v_k,v_j\rangle$，则 $e(i)=ve(k)$
- 活动 $a_i$ 的最迟开始时间 $l(i)$：活动必须开始的最迟时间。若 $a_i=\langle v_k,v_j\rangle$，则 $l(i)=vl(j)-\text{weight}(v_k,v_j)$
- $d(i)=l(i)-e(i)$：活动 $a_i$ 完成的时间余量。若 $d(i)=0$ 则称 $a_i$ 是关键活动

##### 求解关键路径

1. 从源点出发求所有顶点的 $ve()$
2. 从汇点出发求所有顶点的 $vl()$
3. 根据各顶点的 $ve()$ 求各弧的 $e()$
4. 根据各顶点的 $vl()$ 求各弧的 $l()$
5. 求所有活动的 $d()$，所有 $d()=0$ 的关键活动构成关键路径

- 关键路径上的所有活动都是关键活动，加快关键活动可以缩短整个工程的工期。但一个关键活动缩短到一定程度可能变成非关键活动
- 关键路径可能不唯一，此时只加快一条关键路径上的活动不能缩短整体工期，需要加快**包括在所有关键路径上**的关键活动（桥）

## 查找

1. 查找表
   : 用于查找的数据集合
2. 静态查找表
   : 无需动态修改的查找表。适合顺序查找、折半查找、散列查找
3. 动态查找表
   : 存在动态修改的查找表。适合二叉排序树、散列查找
4. 关键字
   : 唯一标识数据元素的某个数据项值，使用基于关键字的查找，查找结果唯一
5. 平均查找长度（Average Search Length, ASL）
   : 所有查找过程中关键词比较次数的平均值

   $$ ASL=\sum_{i=1}^nP_iC_i $$

   $n$ 为查找表的长度；$P_i$ 为查找第 $i$ 个数据元素的概率，一般认为 $P_i=\frac{1}{n}$；$C_i$ 为查找第 $i$ 个数据元素所需的比较次数

### 顺序查找

#### 一般线性表的顺序查找

查找表的 $0$ 下标处设置**哨兵**，关键字与给定值 `key` 相同。逆序查找，查找至 $0$ 时跳出循环，表明查找失败

定位第 $i$ 个元素时需进行 $n-i+1$ 次比较，概率相等时有

$$ ASL_\text{suc}=\sum_{i=1}^n\frac{n-i+1}{n}=\frac{n+1}{2} $$

查找不成功时需进行 $n+1$ 次比较

$$ ASL_\text{fail}=n+1 $$

- 若能预先得知查找概率，可令各项记录按查找概率排序，提高查找效率
- $n$ 较大时效率低
- 对数据的存储以及有序性没有要求
- **线性链表只能顺序查找**

#### 有序表的顺序查找

表中关键字有序，可降低查找失败时的 ASL。假设表中关键字从小到大排列，查找顺序从前往后，$n$ 个元素共有 $n+1$ 个查找失败区间

设概率相等，查找成功时同一般线性表

$$ ASL_\text{suc}=\frac{n+1}{2} $$

查找失败时，进入第 $i$ 个失败区间需进行 $i$ 次比较 $(i\leq n)$，进入第 $n+1$ 个区间需进行 $n$ 次比较

$$ ASL_\text{fail}=\frac{n}{n+1}+\sum_{i=1}^n\frac{i}{n+1}=\frac{n}{2}+\frac{n}{n+1} $$

### 折半查找（二分查找）

仅适用于**有序的顺序表**  
给定值首先与中间位置的元素比较，若小于则在前半部分查找，若大于则在后半部分查找  
查找过程可用二叉树描述，称为判定树，为平衡二叉树

比较次数不会超过树的高度

$$ ASL=\frac{1}{n}(1\times1+2\times2+\cdots+h\times2^{h-1})=\frac{n+1}{n}\log_2(n+1)-1\approx\log_2(n+1)-1 $$

- 时间复杂度 $O(\log n)$
- 需要线性表具有随机存取的特性，仅适合顺序表，不适用于链表

### 分块查找（索引顺序查找）

将查找表分为若干子块，块内可无序，块间有序（第一块的最大值小于第二块的最小值）  
建立索引表，表中每项含有各块的最大关键字和第一个元素的地址，索引表有序排列

1. 在索引表中确定块（顺序查找或折半查找）
2. 在块内顺序查找

ASL 为索引查找和块内查找的 ASL 之和  
设查找表分为 $b$ 块，每块包含 $s$ 个记录，$n=bs$，概率相等，均采用顺序查找

$$ ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s} $$

取 $s=\sqrt{n}$ 得最小值

$$ ASL=\sqrt{n}+1 $$

若索引表采用折半查找

$$ ASL=\lceil\log_2(b+1)\rceil+\frac{s+1}{2} $$

### 二叉排序树（Binary Search Tree, BST）

左子树上的所有值小于根结点，右子树上的所有值大于根结点（递归定义）

- 查找：给定值首先与根结点比较，若小于则在左子树上查找，若大于则在右子树上查找
- 插入：若为空直接插入结点，若小于则在左子树上插入，若大于则在右子树上插入。插入后的结点一定是叶结点，为查找路径上最后一个结点的孩子
- 删除：根据结点 $z$ 的类型分为三种情况

  1. $z$ 为叶结点，直接删除
  2. $z$ 只有左子树/右子树，用左子树/右子树代替 $z$ 的位置
  3. $z$ 有左子树和右子树，用 $z$ 的直接前驱（或直接后继）$p$ 代替 $z$ 的位置，改为从树中删除 $p$

查找效率主要取决于树的高度  
若为平衡二叉树，时间复杂度 $O(\log n)$  
若为单支树，时间复杂度 $O(n)$，类似有序单链表  
最坏情况下，有序输入形成倾斜的单支树

- 二叉排序树与二分查找的查找过程和平均时间性能类似
- 二分查找的判定树唯一，二叉排序树不唯一
- 在二叉排序树中插入删除只需修改指针，时间复杂度 $O(\log n)$；有序顺序表的插入删除时间复杂度 $O(n)$
- 静态查找表宜用有序顺序表二分查找，动态查找表宜用二叉排序树

### 平衡二叉树（Balanced Binary Tree, AVL）

左子树和右子树深度差不超过 $1$（递归定义）

平衡因子：左子树与右子树的高度差

#### 平衡二叉树的插入

插入结点时找到找到插入路径上最近的平衡因子绝对值大于 $1$ 的结点（最小非平衡子树），对该子树的结点位置进行调整

1. LL 平衡旋转（右单旋转）：$A$ 的左孩子（L）$B$ 的左子树（L）插入新结点，$A$ 非平衡

   $B$ 右上旋转成为根结点，$A$ 成为 $B$ 的右孩子。$B$ 的原右子树成为 $A$ 的左子树

   ```mermaid
   flowchart LR
       subgraph Before
           direction TB
           a((A)) --- b((B))
           a --- ar[AR]
           b --- bl[BL]
           b --- br[BR]
       end
       subgraph After
           direction TB
           b'((B)) --- bl'[BL]
           b' --- a'((A))
           a' --- br'[BR]
           a' --- ar'[AR]
       end
       Before --> After
   ```

2. RR 平衡旋转（左单旋转）：$A$ 的右孩子（R）$B$ 的右子树（R）插入新结点，$A$ 非平衡

   $B$ 左上旋转成为根结点，$A$ 成为 $B$ 的左孩子。$B$ 的原左子树成为 $A$ 的右子树

   ```mermaid
   flowchart LR
       subgraph Before
           direction TB
           a((A)) --- al[AL]
           a --- b((B))
           b --- bl[BL]
           b --- br[BR]
       end
       subgraph After
           direction TB
           b'((B)) --- a'((A))
           b' --- br'[BR]
           a' --- al'[AL]
           a' --- bl'[BL]
       end
       Before --> After
   ```

3. LR 平衡旋转（先左后右双旋转）：$A$ 的左孩子（L）$B$ 的右子树（R）$C$ 插入新结点，$A$ 非平衡

   对 $B$ 进行 RR 旋转，再对 $A$ 进行 LL 旋转。根结点为 $C$

4. RL 平衡旋转（先右后左双旋转）：$A$ 的右孩子（R）$B$ 的左子树（L）$C$ 插入新结点，$A$ 非平衡

   对 $B$ 进行 LL 旋转，再对 $A$ 进行 RR 旋转。根结点为 $C$

- LR 和 RL 旋转中，结点插入在 $C$ 的左/右子树不影响旋转过程

#### 平衡二叉树的删除

首先删除结点，方法同 [BST](#二叉排序树binary-search-tree-bst)。从被删除的结点开始向上回溯，找到最近的不平衡结点（最小非平衡子树）$A$，$B$ 为 $A$ 的最高子树，$C$ 为 $B$ 的最高子树，对 $A$ 进行旋转调整

1. $B$ 为 $A$ 的左孩子，$C$ 为 $B$ 的左孩子：LL
2. $B$ 为 $A$ 的右孩子，$C$ 为 $B$ 的右孩子：RR
3. $B$ 为 $A$ 的左孩子，$C$ 为 $B$ 的右孩子：LR
4. $B$ 为 $A$ 的右孩子，$C$ 为 $B$ 的左孩子：RL

- 与插入时不同，删除时对 $A$ 调整完之后可能需要向上回溯，对其祖先进行调整

#### 平衡二叉树的查找

平衡二叉树的最大深度为 $O(\log n)$，查找的时间复杂度 $O(\log n)$

### 红黑树

红黑树是一种二叉排序树，满足

1. 每个结点为红色 :red_circle: 或黑色 :black_circle:
2. 根结点为黑色 :black_circle:
3. 使用 $n+1$ 个虚拟外部结点作为叶结点，黑色 :black_circle:
4. 不存在相邻的红结点
5. 对每个结点，它到任一叶结点的简单路径上包含相同数量的黑结点，称为该结点的黑高（Black Height, bh）**（不含该结点自身）**

根结点的黑高即为红黑树的黑高

#### 红黑树的性质

1. 从根到叶结点的最长路径不大于最短路径的 $2$ 倍

   > 最短路径上均为黑结点，最长路径上为红黑交替

2. 包含 $n$ 个内部结点，高度 $h\leq2\log_2(n+1)$

   > 根结点的黑高至少为 $\frac{h}{2}$，$n\geq2^\frac{h}{2}-1$

相比 AVL，红黑树的要求放宽至左右子树高度相差不超过两倍，降低动态操作时调整的频率

#### 红黑树的插入

插入后的调整主要为重新着色和旋转

1. 插入新结点 $A$，方法同 [BST](#二叉排序树binary-search-tree-bst)，着色为红色 :red_circle:
2. 若 $A$ 的父结点为黑色 :black_circle:，无需做调整
3. 若 $A$ 为根结点，将 $A$ 着色为黑色 :black_circle:
4. 若 $A$ 的父结点 $B$ 为红色 :red_circle:，则 $B$ 的父结点 $C$ 为黑色 :black_circle:

   1. $B$ 的兄弟为黑色，$A$ 为左孩子：$C$ 进行 LL 旋转，交换 $B$ 和 $C$ 的颜色

      ```mermaid
      flowchart LR
          subgraph Before
              direction TB
              c((C)) --- b((B))
              c --- cr[CR]
              b --- a((A))
              b --- br[BR]
              a --- al[AL]
              a --- ar[AR]
              style c fill:#000,color:#fff
              style b fill:#f00,color:#fff
              style cr fill:#000,color:#fff
              style a fill:#f00,color:#fff
              style br fill:#000,color:#fff
              style al fill:#000,color:#fff
              style ar fill:#000,color:#fff
          end
          subgraph After
              direction TB
              b'((B)) --- a'((A))
              b' --- c'((C))
              a' --- al'[AL]
              a' --- ar'[AR]
              c' --- br'[BR]
              c' --- cr'[CR]
              style b' fill:#000,color:#fff
              style a' fill:#f00,color:#fff
              style c' fill:#f00,color:#fff
              style al' fill:#000,color:#fff
              style ar' fill:#000,color:#fff
              style br' fill:#000,color:#fff
              style cr' fill:#000,color:#fff
          end
          Before --> After
      ```

   2. $B$ 的兄弟为黑色，$A$ 为右孩子：$C$ 进行 LR 旋转，左旋后即变为情况一

      ```mermaid
      flowchart LR
          subgraph Before
              direction TB
              c((C)) --- b((B))
              c --- cr[CR]
              b --- bl[BL]
              b --- a((A))
              a --- al[AL]
              a --- ar[AR]
              style c fill:#000,color:#fff
              style b fill:#f00,color:#fff
              style cr fill:#000,color:#fff
              style bl fill:#000,color:#fff
              style a fill:#f00,color:#fff
              style al fill:#000,color:#fff
              style ar fill:#000,color:#fff
          end
          subgraph After
              direction TB
              c'((C)) --- a'((A))
              c' --- cr'[CR]
              a' --- b'((B))
              a' --- ar'[AR]
              b' --- bl'[BL]
              b' --- al'[AL]
              style c' fill:#000,color:#fff
              style a' fill:#f00,color:#fff
              style cr' fill:#000,color:#fff
              style b' fill:#f00,color:#fff
              style ar' fill:#000,color:#fff
              style bl' fill:#000,color:#fff
              style al' fill:#000,color:#fff
          end
          Before --> After
      ```

   3. $B$ 的兄弟 $D$ 为红色：此时 $A$ 为左/右孩子无影响。将 $B$ 和 $D$ 着为黑色，$C$ 着为红色。把 $C$ 作为新插入的结点继续调整

      ```mermaid
      flowchart LR
          subgraph Before
              direction TB
              c((C)) --- b((B))
              c --- d((D))
              b --- a((A))
              b --- br[BR]
              d --- dl[DL]
              d --- dr[DR]
              a --- al[AL]
              a --- ar[AR]
              style c fill:#000,color:#fff
              style b fill:#f00,color:#fff
              style d fill:#f00,color:#fff
              style a fill:#f00,color:#fff
              style br fill:#000,color:#fff
              style dl fill:#000,color:#fff
              style dr fill:#000,color:#fff
              style al fill:#000,color:#fff
              style ar fill:#000,color:#fff
          end
          subgraph After
              direction TB
              c'((C)) --- b'((B))
              c' --- d'((D))
              b' --- a'((A))
              b' --- br'[BR]
              d' --- dl'[DL]
              d' --- dr'[DR]
              a' --- al'[AL]
              a' --- ar'[AR]
              style c' fill:#f00,color:#fff
              style b' fill:#000,color:#fff
              style d' fill:#000,color:#fff
              style a' fill:#f00,color:#fff
              style br' fill:#000,color:#fff
              style dl' fill:#000,color:#fff
              style dr' fill:#000,color:#fff
              style al' fill:#000,color:#fff
              style ar' fill:#000,color:#fff
          end
          Before --> After
      ```

   - 其中所有子树都具有黑色的根结点，且有相同的黑高
   - 当 $B$ 为 $C$ 的右孩子时情况类似，对称操作

#### 红黑树的删除

删除结点方法同 BST，最后转换为删除叶结点或仅有一个子树的结点 $z$

1. $z$ 只有一个子树：此时 $z$ 必为黑色，子树仅有一个结点且为红色。将 $z$ 删除，并将孩子着为黑色
2. $z$ 为叶结点且为红色：直接删除
3. $z$ 为叶结点且为黑色：删除 $z$，代替 $z$ 位置的结点 $A$ 视为双黑结点，将 $A$ 转换为普通结点

   $A$ 的父结点为 $B$，$A$ 的兄弟为 $C$

   1. $C$ 为红色：$B$、$C$ 颜色互换，$B$ 进行 RR 旋转，转化为情况二/三/四

      ```mermaid
      flowchart LR
          subgraph Before
              direction TB
              b((B)) --- a{A}
              b --- c((C))
              a --- al[AL]
              a --- ar[AR]
              c --- cl[CL]
              c --- cr[CR]
              style b fill:#000,color:#fff
              style a fill:#000,color:#fff
              style c fill:#f00,color:#fff
              style al fill:#fff,color:#000
              style ar fill:#fff,color:#000
              style cl fill:#000,color:#fff
              style cr fill:#000,color:#fff
          end
          subgraph After
              direction TB
              c'((C)) --- b'((B))
              c' --- cr'[CR]
              b' --- a'{A}
              b' --- cl'[CL]
              a' --- al'[AL]
              a' --- ar'[AR]
              style c' fill:#000,color:#fff
              style b' fill:#f00,color:#fff
              style cr' fill:#000,color:#fff
              style a' fill:#000,color:#fff
              style cl' fill:#000,color:#fff
              style al' fill:#fff,color:#000
              style ar' fill:#fff,color:#000
          end
          Before --> After
      ```

   2. $C$ 为黑色，$C$ 的左孩子 $D$ 为红色，右孩子为黑色：$C$、$D$ 颜色互换，$C$ 进行 LL 旋转，转化为情况三

      ```mermaid
      flowchart LR
          subgraph Before
              direction TB
              b((B)) --- a{A}
              b --- c((C))
              a --- al[AL]
              a --- ar[AR]
              c --- d((D))
              c --- cr[CR]
              d --- dl[DL]
              d --- dr[DR]
              style b fill:#fff,color:#000
              style a fill:#000,color:#fff
              style c fill:#000,color:#fff
              style al fill:#fff,color:#000
              style ar fill:#fff,color:#000
              style d fill:#f00,color:#fff
              style cr fill:#000,color:#fff
              style dl fill:#000,color:#fff
              style dr fill:#000,color:#fff
          end
          subgraph After
              direction TB
              b'((B)) --- a'{A}
              b' --- d'((D))
              a' --- al'[AL]
              a' --- ar'[AR]
              d' --- dl'[DL]
              d' --- c'((C))
              c' --- dr'[DR]
              c' --- cr'[CR]
              style b' fill:#fff,color:#000
              style a' fill:#000,color:#fff
              style d' fill:#000,color:#fff
              style al' fill:#fff,color:#000
              style ar' fill:#fff,color:#000
              style dl' fill:#000,color:#fff
              style c' fill:#f00,color:#fff
              style dr' fill:#000,color:#fff
              style cr' fill:#000,color:#fff
          end
          Before --> After
      ```

   3. $C$ 为黑色，$C$ 的右孩子 $D$ 为红色：$B$、$C$ 颜色互换，$D$ 着为黑色，$B$ 进行 RR 旋转，将 $A$ 改为普通黑色结点

      ```mermaid
      flowchart LR
          subgraph Before
              direction TB
              b((B)) --- a{A}
              b --- c((C))
              a --- al[AL]
              a --- ar[AR]
              c --- cl[CL]
              c --- d((D))
              d --- dl[DL]
              d --- dr[DR]
              style b fill:#fff,color:#000
              style a fill:#000,color:#fff
              style c fill:#000,color:#fff
              style al fill:#fff,color:#000
              style ar fill:#fff,color:#000
              style cl fill:#fff,color:#000
              style d fill:#f00,color:#fff
              style dl fill:#000,color:#fff
              style dr fill:#000,color:#fff
          end
          subgraph After
              direction TB
              c'((C)) --- b'((B))
              c' --- d'((D))
              b' --- a'((A))
              b' --- cl'[CL]
              d' --- dl'[DL]
              d' --- dr'[DR]
              a' --- al'[AL]
              a' --- ar'[AR]
              style c' fill:#fff,color:#000
              style b' fill:#000,color:#fff
              style d' fill:#000,color:#fff
              style a' fill:#000,color:#fff
              style cl' fill:#fff,color:#000
              style dl' fill:#000,color:#fff
              style dr' fill:#000,color:#fff
              style al' fill:#fff,color:#000
              style ar' fill:#fff,color:#000
          end
          Before --> After
      ```

   4. $C$ 为黑色，$C$ 的孩子均为黑色：$A$ 变为普通黑色结点，$C$ 着为红色，$B$ 上多加一层黑色。此时若 $B$ 为红色则变为黑色，若 $B$ 为黑色则视为双黑结点，继续调整

      ```mermaid
      flowchart LR
          subgraph Before
              direction TB
              b((B)) --- a{A}
              b --- c((C))
              a --- al[AL]
              a --- ar[AR]
              c --- cl[CL]
              c --- cr[CR]
              style b fill:#fff,color:#000
              style a fill:#000,color:#fff
              style c fill:#000,color:#fff
              style al fill:#fff,color:#000
              style ar fill:#fff,color:#000
              style cl fill:#000,color:#fff
              style cr fill:#000,color:#fff
          end
          subgraph After
              direction TB
              b'((B)) --- a'((A))
              b' --- c'((C))
              a' --- al'[AL]
              a' --- ar'[AR]
              c' --- cl'[CL]
              c' --- cr'[CR]
              style b' fill:#000,color:#fff
              style a' fill:#000,color:#fff
              style c' fill:#f00,color:#fff
              style al' fill:#fff,color:#000
              style ar' fill:#fff,color:#000
              style cl' fill:#000,color:#fff
              style cr' fill:#000,color:#fff
          end
          Before --> After
      ```

### B 树（多路平衡查找树）

B 树中所有结点的孩子个数最大值称为 B 树的阶，$m$ 阶 B 树满足：

1. 每个结点至多有 $m$ 棵子树，即至多有 $m-1$ 个关键字
2. 根结点至少有两棵子树（若不是终端结点）
3. 根结点以外的所有非叶结点至少有 $\lceil\frac{m}{2}\rceil$ 棵子树，即至少有 $\lceil\frac{m}{2}\rceil-1$ 个关键字
4. 子树中的所有关键字大于其指针的前一个关键字，小于后一个关键字
5. 所有叶结点在同一层，不包含信息，可视为虚拟的外部结点

- B 树的高度 $h$ 不包含虚拟叶结点
- 设有 $n$ 个关键字，$n\leq m^h-1$，即 $h\geq\log_m(n+1)$
- $n+1\geq2(\lceil\frac{m}{2}\rceil)^{h-1}$，即 $h\leq1+\log_{\lceil\frac{m}{2}\rceil}\frac{n+1}{2}$

#### B 树的查找

1. B 树存储在磁盘上，查找到结点后读入内存，在结点内查找关键字（顺序查找/折半查找）
2. 若关键字不存在，则在对应区间的子树上继续查找
3. 若查找至叶结点（即空指针），查找失败

#### B 树的插入

1. 利用查找算法找到插入 `key` 的最低非叶结点
2. 若插入后关键字数 $\leq m-1$，可直接插入
3. 若插入后关键字数 $>m-1$，需要分裂结点。将结点从中间（$\lceil\frac{m}{2}\rceil$）分裂为左右两个，中间的关键字加入父结点。若导致父结点关键字超过上限，则继续调整

#### B 树的删除

删除关键字，若不位于最低非叶结点，使用其直接前驱（或直接后继）代替，改为删除该关键字  
因此仅考虑删除最低非叶结点中的关键字

1. 若删除前关键字数 $\geq\lceil\frac{m}{2}\rceil$，可直接删除
2. 若删除前关键字数 $=\lceil\frac{m}{2}\rceil-1$，与其相邻的兄弟的关键字数 $\geq\lceil\frac{m}{2}\rceil$，使用父子换位法调整
3. 若删除前关键字数 $=\lceil\frac{m}{2}\rceil-1$，且兄弟不够借，则在删除后将其与左（或右）兄弟及父结点中的关键字合并。此时父结点的关键字数减 $1$，若导致低于下限，则继续调整

### B+ 树

B+ 树结点中**每个关键字对应一棵子树**

1. 每个结点至多有 $m$ 棵子树，即 $m$ 个关键字
2. 根结点至少有两棵子树（若不是终端结点）
3. 根结点以外的所有非叶结点至少有 $\lceil\frac{m}{2}\rceil$ 棵子树，即 $\lceil\frac{m}{2}\rceil$ 个关键字
4. 分支结点中的各个关键字为其指向的子结点关键字的最大值
5. 所有叶结点包含全部关键字，按大小顺序排列，由指针指向对应记录。叶结点按顺序相互链接

- 包含两个头指针，分别指向根结点和关键字最小的叶结点

### 散列表

散列函数：把关键字映射成对应地址的函数

- 定义域应包含所有关键字
- 计算所得的地址应等概率、均匀分布，减少冲突发生
- 尽量简单，计算速度快

冲突：散列函数将不同关键字映射到同一地址。好的散列函数尽量避免冲突，同时要设计好处理冲突的方法  
散列表：根据关键字直接进行访问的数据结构

#### 散列函数的构造

1. 直接定址法：取关键字的线性函数为散列地址

   $$ H(key)=a\times key+b $$

   计算简单，没有冲突。适合关键字分布基本连续的情况，否则容易造成存储空间浪费

2. 除留余数法：设散列表长度为 $m$，取不大于 $m$ 的最大素数 $p$

   $$ H(key)=key\bmod p $$

   最简单最常用的方法。能否等概率地映射关键在 $p$ 的选择

3. 数字分析法：设关键字为 $r$ 进制数，取 $r$ 个数码分布较为均匀的若干位作为散列地址。适用于已知的关键字集合，更换关键字集合需要重新构造函数
4. 平方取中法：取关键字平方的中间若干位（视情况而定）作为散列地址。得到的地址与关键字的每一位都有关系，使得分布较为均匀。适用于关键字的每一位取值都不够均匀或均小于散列地址所需的位数

#### 处理冲突的方法

1. 开放定址法

   $$ H_i=(H(key)+d_i)\bmod m $$

   $d_i$ 为增量序列，有四种取法

   1. 线性探测法：$d_i=0,1,2,\cdots,m-1$

      冲突发生时顺序查看下一个单元，直到找到空闲单元。使得大量元素在相邻的散列单元中堆积，降低查找效率

   2. 平方探测法（二次探测法）：$d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2$，其中 $k\leq\frac{m}{2}$

      **$m$ 必须是可表示为 $4k+3$ 的素数**。可避免堆积问题，无法探测到所有单元，但至少可探测到一半单元

   3. 双散列法：$d_i=H_2(key)$，其中 $H_2$ 为第二个散列函数

      $$ H_i=(H(key)+i\times H_2(key))\bmod m $$

   4. 伪随机序列法：$d_i$ 为伪随机序列

   开放定址法不能随便删除表中已有的元素，否则会影响其他具有相同地址元素的查找。删除时可做一个删除标记，但由于是逻辑删除，会导致表中产生许多未利用的位置。需要定期维护散列表，物理删除被标记的元素

2. 拉链法（链接法）

   将所有冲突的元素存储在一个线性链表中，散列表单元中存储头指针。适用于经常进行插入和删除的情况

#### 散列查找

1. `Addr = H(key)`
2. 查找表中地址为 `Addr` 的位置是否有记录，若无记录则查找失败；若有记录则比较它与 `key` 的值
3. 记录与 `key` 的值相等则查找成功，否则用给定的冲突处理方法计算下一个散列地址 `Addr`，重复上一步

- 装填因子：散列表长度为 $m$，表中记录数为 $n$，装填因子为 $\alpha$

  $$ \alpha=\frac{n}{m} $$

  散列表的平均查找长度依赖于 $\alpha$，而不直接依赖于 $n$ 或 $m$

## 排序

稳定性
: 两个元素关键字相同，应用算法后两个元素的前后关系不变，则称排序算法是稳定的

内部排序
: 排序期间元素全部存放在内存中

外部排序
: 排序期间元素无法全部同时存放在内存中，必须不断在内外存之间移动

时间复杂度一般由比较和移动的次数决定

- 大部分排序算法仅适用于顺序表

### 插入排序

#### 直接插入排序

[代码实现](./Algorithm/InsertionSort.cpp)

- 使用哨兵
- 边比较边移动

最好时间复杂度 $O(n)$，有序  
最坏时间复杂度 $O(n^2)$，逆序  
平均时间复杂度 $O(n^2)$  
空间复杂度 $O(1)$  
稳定性 :o:  
适用于顺序表和链表。链表可从前往后查找指定元素的位置

#### 折半插入排序

[代码实现](./Algorithm/InsertionSort.cpp)

- 将比较和移动分离，首先折半查找位置，再统一移动元素
- 减少了比较次数，$O(n\log n)$。移动次数未改变

平均时间复杂度 $O(n^2)$  
稳定性 :o:  
适用于顺序表。对于数据量不大的排序表具有较好的性能

#### 希尔排序

[代码实现](./Algorithm/ShellSort.cpp)

- 缩小增量排序
- 以步长 $d_i$ 对记录分组，组内直接插入排序
- 逐步减小步长至 $1$

时间复杂度依赖于增量序列的选取  
最坏时间复杂度 $O(n^2)$  
$n$ 在某个特定范围时，时间复杂度 $O(n^{1.3})$  
空间复杂度 $O(1)$  
稳定性 :x:  
仅适用于顺序表

### 交换排序

#### 冒泡排序

[代码实现](./Algorithm/BubbleSort.cpp)

- 每趟冒泡会将序列中的最小（或最大）元素放到最终位置

最好时间复杂度 $O(n)$，有序  
最坏时间复杂度 $O(n^2)$，逆序  
平均时间复杂度 $O(n^2)$  
空间复杂度 $O(1)$  
稳定性 :o:

#### 快速排序

[代码实现](./Algorithm/QuickSort.cpp)

- 将第一个元素作为 `pivot`，每趟排序会将 `pivot` 放到最终位置
- 需要借助递归工作栈
- 选取可将数据中分的 `pivot`（选取头尾中间值或随机），可尽量避免最坏情况，提高效率
- 内部排序算法中平均性能最优的算法

最好时间复杂度 $O(n\log n)$，平衡划分  
最坏时间复杂度 $O(n^2)$，划分不对称，即基本有序或基本逆序  
平均时间复杂度 $O(n\log n)$  
最好空间复杂度 $O(\log n)$  
最坏空间复杂度 $O(n)$  
平均空间复杂度 $O(\log n)$  
稳定性 :x:

### 选择排序

#### 简单选择排序

[代码实现](./Algorithm/SelectionSort.cpp)

时间复杂度始终是 $O(n^2)$  
空间复杂度 $O(1)$  
稳定性 :x:

#### 堆排序

[代码实现](./Algorithm/HeapSort.cpp)

$n$ 个关键字的序列 $L$，下标 $1\cdots n$，满足

1. 大根堆：$L(i)\geq L(2i)$ 且 $L(i)\geq L(2i+1)$
2. 小根堆：$L(i)\leq L(2i)$ 且 $L(i)\leq L(2i+1)$

堆可视为完全二叉树，根结点存放最大（最小）的元素

- 构造初始堆时自下往上调整子树，时间复杂度 $O(n)$
- 输出堆顶后将最后一个元素置于堆顶，自上往下与较大元素交换，时间复杂度 $O(\log n)$，共执行 $n-1$ 次

时间复杂度 $O(n\log n)$  
空间复杂度 $O(1)$  
稳定性 :x:

### 归并排序

[代码实现](./Algorithm/MergeSort.cpp)

- 将两个有序表组合为一个有序表，$2$ 路归并排序
- 需要辅助数组复制原数组的元素

时间复杂度 $O(n\log n)$  
空间复杂度 $O(n)$  
稳定性 :o:

### 基数排序

[代码实现](./Algorithm/RadixSort.cpp)

- 关键字为 $d$ 位以 $r$ 为基数的整数
- 最高位优先（Most Significant Digit, MSD）、最低位优先（Least Significant Digit, LSD）

LSD 中：

1. 需要 $r$ 个队列
2. 依次扫描数组元素，位数字为 $i$，进入队列 $i$
3. 依次连接各个队列，得到新的序列
4. 从低位开始，重复 $d$ 次

时间复杂度 $O(d(n+r))$  
空间复杂度 $O(r)$  
稳定性 :o:  
通常使用链表

### 排序算法的应用

| 排序算法 | 最佳时间复杂度 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度  | 稳定性 |
| :------: | :------------: | :------------: | :------------: | :---------: | :----: |
|   插入   |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |   $O(1)$    |  :o:   |
|   冒泡   |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |   $O(1)$    |  :o:   |
|   选择   |    $O(n^2)$    |    $O(n^2)$    |    $O(n^2)$    |   $O(1)$    |  :x:   |
|   希尔   |                |                |                |   $O(1)$    |  :x:   |
|   快速   |  $O(n\log n)$  |  $O(n\log n)$  |    $O(n^2)$    | $O(\log n)$ |  :x:   |
|    堆    |  $O(n\log n)$  |  $O(n\log n)$  |  $O(n\log n)$  |   $O(1)$    |  :x:   |
|   归并   |  $O(n\log n)$  |  $O(n\log n)$  |  $O(n\log n)$  |   $O(n)$    |  :o:   |
|   基数   |  $O(d(n+r))$   |  $O(d(n+r))$   |  $O(d(n+r))$   |   $O(r)$    |  :o:   |

平均时间复杂度为 $O(n\log n)$ 的稳定排序算法只有归并排序

1. $n$ 较小，可采用**直接插入排序**或**简单选择排序**。记录本身信息量较大时采用**简单选择排序**
2. 初始状态基本有序，采用**直接插入排序**或**冒泡排序**
3. $n$ 较大，采用时间复杂度为 $O(n\log n)$ 的排序算法

   - 关键字随机分布时采用**快速排序**
   - **堆排序**需要的辅助空间少于**快速排序**，并且不会出现最坏情况
   - **归并排序**稳定，可结合**直接插入排序**一起使用

4. 基于比较的排序算法可以用二叉树描述比较过程，可以证明基于比较的算法在关键字随机分布时至少需要 $O(n\log n)$ 的时间
5. $n$ 很大，关键字位数较少且可分解，采用**基数排序**
6. 记录本身信息量较大，避免大量移动的开销，使用链表作为存储结构

### 外部排序

排序文件较大，无法整个放入内存进行排序，需要一部分一部分从外存调入内存  
时间代价主要考虑访问磁盘的次数，即 I/O 次数

外部排序通常采用归并排序法

1. 根据内存缓冲区大小，将外存上的文件分成若干长度为 $l$ 的子文件，称为**归并段**或**顺串**，依次读入内存进行内部排序，并写回外存
2. 内存工作区等分为两个输入缓冲区和一个输出缓冲区
3. 对归并段进行逐趟归并，期间需要将数据不停地读出、写入磁盘

$$ 外部排序时间=内部排序时间+外存信息读写时间+内部归并时间 $$

外存信息读写时间远大于内部排序时间和内部归并时间

- 记录总共占用 $n$ 个磁盘块，则每趟归并需要进行 $n$ 次读和 $n$ 次写
- 增大归并路数，减少归并趟数，可减少总 I/O 次数

$r$ 个初始归并段，$k$ 路平衡归并，归并趟数 $S=\lceil\log_kr\rceil$，每趟归并将 $m$ 个归并段归并为 $\lceil\frac{m}{k}\rceil$ 个归并段。

#### 多路平衡归并与败者树

内部 $k$ 路归并需要比较 $k-1$ 次，归并 $n$ 个元素需要比较 $(n-1)(k-1)$ 次，$S$ 趟归并总的比较次数为

$$ S(n-1)(k-1)=\lceil\log_kr\rceil(n-1)(k-1)=\lceil\log_2r\rceil(n-1)\frac{k-1}{\log_2k} $$

增加归并路数时，内部归并时间会增加  
增加归并路数时，需要相应地增加输入缓冲区的个数，减少缓冲区的容量，增加数据交换的次数

##### 败者树

完全二叉树

1. $k$ 个叶结点，分别存放各个归并段当前参加比较的记录
2. 内部结点用于记忆左右子树中的败者（归并段号），胜者向上继续进行比较（设较小为胜者，较大为败者）
3. 根结点指向的段的关键字最小
4. 输出最小值，将该归并段的下一个关键字填入叶结点，继续比较

内部 $k$ 路归并最多需要比较 $\lceil\log_2k\rceil$ 次，归并总的比较次数为

$$ \lceil\log_2r\rceil(n-1) $$

此时内部归并的比较次数与归并路数 $k$ 无关  
增加归并路数可以减少归并趟数，提高排序速度

#### 置换-选择排序（生成初始归并段）

减少初始归并段个数 $r$ 也可减少趟数 $S$，因此要产生更长的初始归并段

初始待排文件为 FI，初始归并段输出文件为 FO，内存工作区 WA 可容纳 $w$ 个记录  
FO 和 WA 初始为空

1. 从 FI 输入 $w$ 个记录到 WA
2. 从 WA 中选出关键字最小的记录（利用败者树），记为 MINIMAX
3. MINIMAX 输出到 FO
4. 若 FI 不空，输入下一个记录到 WA
5. 从 WA 中关键字大于 MINIMAX 的记录中选出最小的记录，作为新的 MINIMAX
6. 重复 3 ~ 5，直至选不出新的 MINIMAX，输出归并段的结束标志到 FO
7. 重复 2 ~ 6，直至 WA 为空，此时 FO 中即为所有初始归并段

#### 最佳归并树

初始归并段长度不等  
归并路数为 $k$，根据归并段长度构造 $k$ 叉[哈夫曼树](#哈夫曼树)  
树的带权路径长度 WPL 为归并过程中的总读记录数，I/O 次数为 $2\times\text{WPL}$

构造严格 $k$ 叉树（结点的度为 $0$ 或 $k$）  
叶结点为 $n_0$ 个，度为 $k$ 的结点为 $n_k$ 个，有 $n_0+n_k=kn_k+1$，即 $n_k=\frac{n_0-1}{k-1}$

- $(n_0-1)\bmod(k-1)=0$，可以构造严格 $k$ 叉树
- $(n_0-1)\bmod(k-1)=u\neq0$，加上 $k-1-u$ 个空叶结点
